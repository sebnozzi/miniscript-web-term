{
  "version": 3,
  "sources": ["../../miniscript.ts/src/parser/tokenTypes.ts", "../../miniscript.ts/src/parser/parserModel.ts", "../../miniscript.ts/src/vm/bytecodes.ts", "../../miniscript.ts/src/vm/funcdef.ts", "../../miniscript.ts/src/vm/sourcemap.ts", "../../miniscript.ts/src/vm/code.ts", "../../miniscript.ts/src/compiler/codebuilder.ts", "../../miniscript.ts/src/compiler/compilerModel.ts", "../../miniscript.ts/src/compiler/expressionCompiler.ts", "../../miniscript.ts/src/compiler/statementCompiler.ts", "../../miniscript.ts/src/compiler/compiler.ts", "../../miniscript.ts/src/debugger/steppers.ts", "../../miniscript.ts/src/debugger/debugger.ts", "../../miniscript.ts/src/lib/hashmap.ts", "../../miniscript.ts/src/lib/random.ts", "../../miniscript.ts/src/lib/stack.ts", "../../miniscript.ts/src/vm/context.ts", "../../miniscript.ts/src/vm/forloop.ts", "../../miniscript.ts/src/vm/frame.ts", "../../miniscript.ts/src/vm/processorState.ts", "../../miniscript.ts/src/vm/signatureParser.ts", "../../miniscript.ts/src/vm/processor.ts", "../../miniscript.ts/src/vm/msmap.ts", "../../miniscript.ts/src/vm/runtime.ts", "../../miniscript.ts/src/intrinsics/standard/bitOperations.ts", "../../miniscript.ts/src/intrinsics/standard/chars.ts", "../../miniscript.ts/src/intrinsics/standard/collections.ts", "../../miniscript.ts/src/intrinsics/standard/conversion.ts", "../../miniscript.ts/src/intrinsics/standard/coreTypes.ts", "../../miniscript.ts/src/intrinsics/standard/identity.ts", "../../miniscript.ts/src/intrinsics/standard/math.ts", "../../miniscript.ts/src/intrinsics/standard/print.ts", "../../miniscript.ts/src/intrinsics/standard/randomness.ts", "../../miniscript.ts/src/intrinsics/standard/scheduling.ts", "../../miniscript.ts/src/intrinsics/standard/string.ts", "../../miniscript.ts/src/intrinsics/intrinsics.ts", "../../miniscript.ts/src/parser/commonModel.ts", "../../miniscript.ts/src/parser/tokenizerModel.ts", "../../miniscript.ts/src/parser/tokenizer.ts", "../../miniscript.ts/src/parser/parser.ts", "../../miniscript.ts/src/runtime/runtimeApi.ts", "../../miniscript.ts/src/interpreter/runners/coopRunner.ts", "../../miniscript.ts/src/interpreter/runners/stdRunner.ts", "../../miniscript.ts/src/interpreter/interpreter.ts", "../src/msTerminal.ts", "../src/index.ts"],
  "sourcesContent": ["export enum TokenType {\n\n  NEWLINE,\n  SEMICOLON,\n\n  STRING_LITERAL,\n  INT_LITERAL,\n  FLOAT_LITERAL,\n  IDENTIFIER_TK,\n\n  OPEN_CURLY,\n  OPEN_SQUARE,\n  OPEN_ROUND,\n\n  CLOSE_CURLY,\n  CLOSE_SQUARE,\n  CLOSE_ROUND,\n\n  DOT,\n  COLON,\n  COMMA,\n\n  ASSIGN,\n  PLUS_ASSIGN,\n  MINUS_ASSIGN,\n  MULT_ASSIGN,\n  DIV_ASSIGN,\n  MOD_ASSIGN,\n  POW_ASSIGN,\n\n  OP_EQUALS,\n  OP_NOT_EQUALS,\n\n  OP_OR,\n  OP_AND,\n\n  OP_LESS,\n  OP_LESS_EQUALS,\n  OP_GREATER,\n  OP_GREATER_EQUALS,\n  \n  OP_PLUS,\n  OP_MINUS,\n  OP_MOD,\n  OP_DIV,\n  OP_MULT,\n  OP_POW,\n\n  OP_NOT,\n  OP_FUNCREF,\n  OP_ISA,\n\n  KW_TRUE,\n  KW_FALSE,\n  KW_NULL,\n  KW_SUPER,\n\n  KW_IF,\n  KW_THEN,\n  KW_ELSE,\n  KW_ELSE_IF,\n\n  KW_WHILE,\n  KW_FOR,\n  KW_IN,\n  KW_BREAK,\n  KW_CONTINUE,\n\n  KW_NEW,\n  KW_FUNCTION,\n  KW_RETURN,\n\n  // Only temporary: combined later to one of the END_X tokens\n  KW_END,\n\n  KW_END_IF,\n  KW_END_FOR,\n  KW_END_WHILE,\n  KW_END_FUNCTION,\n\n  EOF,\n}\n\nexport function toOfficialImplTokenName(tokenType: TokenType): string {\n  switch(tokenType) {\n    case TokenType.COMMA:\n      return \"Comma\"\n    case TokenType.OPEN_ROUND:\n      return \"LParen\"\n    case TokenType.CLOSE_ROUND:\n      return \"RParen\"\n    default:\n      TokenType[tokenType]\n      return `${TokenType[tokenType]}`\n  }\n}", "// TODO: move the whole toJson thing outside of these models.\n// It is only for debugging, they should be external.\n\nimport { SrcLocation } from \"./commonModel\";\nimport { Token, Identifier } from \"./tokenizerModel\";\nimport { TokenType } from \"./tokenTypes\";\n\nexport interface Expression {\n  location(): SrcLocation;\n  toJson(): object;\n  description(): string;\n}\n\ntype OptExpression = Expression | undefined\ntype DefaultArgValue = Literal | undefined;\n\nexport interface Statement {\n  description(): string;\n  toJson(): object\n}\n\ntype jsonCapable = {\n  toJson(): object\n}\n\nfunction toJsonArray(elements: jsonCapable[]): object[] {\n  let result = []\n  for (let e of elements) {\n    result.push(e.toJson())\n  }\n  return result\n}\n\nfunction tokensToJsonArray(tokens: Token[]): any[] {\n  let result = [];\n  for (let token of tokens) {\n    const tokenType = token.tokenType;\n    result.push(TokenType[tokenType].toString());\n  }\n  return result;\n}\n\n// == Statements\n\n// An expression found at the level of a statement\nexport class ExpressionStatement implements Statement {\n  constructor(public expression: Expression) {}\n\n  location() {\n    return this.expression.location()\n  }\n\n  description(): string {\n    return \"Expression Statement\";\n  }\n\n  toJson(): object {\n    return {\n      \"ExpressionStatement\": {\n        \"expression\": this.expression.toJson()\n      }\n    }\n  }\n}\n\nexport class ConditionedStatements {\n  constructor(public condition: Expression, public statements: Statement[]) {}\n  \n  location() {\n    return this.condition.location();\n  }\n\n  toJson(): object {\n    return {\n      \"ConditionedStatements\": {\n        \"condition\": this.condition.toJson(),\n        \"statements\": toJsonArray(this.statements)\n      }\n    }\n  }\n}\n\n\nexport class IfStatement implements Statement {\n  constructor(public ifBranch: ConditionedStatements,\n    public elseIfs: ConditionedStatements[],\n    public elseBranch: Statement[]) {}\n \n  description(): string {\n    return \"If Statement\";\n  }\n\n  toJson(): object {\n    return {\n      \"IfStatement\": {\n        \"ifBranch\": this.ifBranch.toJson(),\n        \"elseIfs\": toJsonArray(this.elseIfs),\n        \"elseBranch\": toJsonArray(this.elseBranch)\n      }\n    }\n  }\n}\n\nexport class WhileStatement implements Statement {\n  constructor(public condition: Expression, public headerLocation: SrcLocation, public statements: Statement[]) { }\n  description(): string {\n    return \"While Statement\";\n  }  \n  toJson(): object {\n    return {\n      \"WhileStatement\": {\n        \"condition\": this.condition.toJson(),\n        \"statements\": toJsonArray(this.statements)\n      }\n    }\n  }\n}\n\nexport class ForStatement implements Statement {\n  constructor(public loopVar: Identifier, public rangeExpr: Expression, public headerLocation: SrcLocation, public statements: Statement[]) {}\n  description(): string {\n    return \"For Statement\";\n  }\n  toJson(): object {\n    return {\n      \"ForStatement\": {\n        \"loopVar\": this.loopVar.value,\n        \"rangeExpr\": this.rangeExpr.toJson(),\n        \"statements\": toJsonArray(this.statements)\n      }\n    }\n  }\n}\n\nexport class AssignmentStatement implements Statement {\n  constructor(public target: Expression, public value: Expression) {}\n  \n  description(): string {\n    return \"Assignment\";\n  }\n\n  location() {\n    return this.target.location().upTo(this.value.location());\n  }\n\n  toJson(): object {\n    return {\n      \"AssignmentStatement\": {\n        \"target\": this.target.toJson(),\n        \"value\": this.value.toJson()\n      }\n    }\n  }\n}\n\nexport class MathAssignmentStatement implements Statement {\n  constructor(public target: Expression, public opToken: TokenType, public value: Expression) {}\n  \n  description(): string {\n    return \"Math-Assignment\";\n  }\n\n  location() {\n    return this.target.location().upTo(this.value.location());\n  }\n\n  toJson(): object {\n    return {\n      \"MathAssignmentStatement\": {\n        \"target\": this.target.toJson(),\n        \"op\": TokenType[this.opToken],\n        \"value\": this.value.toJson()\n      }\n    }\n  }\n}\n\nexport class FunctionCallStatement implements Statement {\n  constructor(public callTarget: Expression, public args: Expression[]) {}\n  description(): string {\n    return \"Function Call Statement\";\n  }\n  location(): SrcLocation {\n    if (this.args.length > 0) {\n      const lastArg = this.args[this.args.length - 1];\n      return this.callTarget.location().upTo(lastArg.location());\n    } else {\n      return this.callTarget.location();\n    }\n  }\n  toJson(): object {\n    return {\n      \"FunctionCallStatement\": {\n        \"callTarget\": this.callTarget.toJson(),\n        \"args\": toJsonArray(this.args)\n      }\n    }\n  }\n}\n\nexport class ReturnStatement implements Statement {\n  constructor(public optValue: OptExpression, private fullLocation: SrcLocation) {}\n  location() {\n    return this.fullLocation;\n  }\n  description(): string {\n    return \"Return Statement\";\n  }\n  toJson(): object {\n    return {\n      \"ReturnStatement\": {\n        \"optValue\": this.optValue ? this.optValue.toJson() : null\n      }\n    }\n  }\n}\n\nexport class BreakStatement implements Statement {\n  constructor(private fullLocation: SrcLocation) {}\n  location() {\n    return this.fullLocation;\n  }\n  description(): string {\n    return \"Break Statement\";\n  }\n  toJson(): object {\n    return {\n      \"BreakStatement\": null\n    }\n  }\n}\n\nexport class ContinueStatement implements Statement {\n  constructor(private fullLocation: SrcLocation) {}\n  location() {\n    return this.fullLocation;\n  }\n  description(): string {\n    return \"Continue Statement\";\n  }\n  toJson(): object {\n    return {\n      \"ContinueStatement\": null\n    }\n  }\n}\n\n// == Expressions\n\nexport class BinaryExpr implements Expression {\n  constructor(public left: Expression, public operator: Token, public right: Expression) {}\n  \n  location() {\n    return this.left.location().upTo(this.right.location());\n  }\n\n  description(): string {\n    return \"Binary Expression\";\n  }\n  \n  toJson(): object {\n    return {\n      \"BinaryExpr\": {\n        \"left\": this.left.toJson(),\n        \"operator\": TokenType[this.operator.tokenType],\n        \"right\": this.right.toJson()\n      }\n    }\n  }\n}\n\nexport class ChainedComparisonExpr {\n  constructor(public operands: Expression[], public operators: Token[]) {\n    if (operands.length < 3) {\n      throw new Error(\"Amount of operands must be at least 3\");\n    }\n    if (operands.length - 1 != operators.length) {\n      throw new Error(\"Amount of operands/operators mismatch\");\n    }\n    for (let tk of operators) {\n      const ttype = tk.tokenType;\n      if (ttype != TokenType.OP_EQUALS\n          && ttype != TokenType.OP_NOT_EQUALS\n          && ttype != TokenType.OP_GREATER \n          && ttype != TokenType.OP_GREATER_EQUALS \n          && ttype != TokenType.OP_LESS\n          && ttype != TokenType.OP_LESS_EQUALS){\n        throw new Error(`Invalid token type: ${TokenType[ttype]}`);\n      }\n    }\n  }\n  \n  location(): SrcLocation {\n    const firstOperand = this.operands[0];\n    const lastOperand = this.operands[this.operands.length - 1];\n    return firstOperand.location().upTo(lastOperand.location());\n  }\n\n  description(): string {\n    return \"Binary Expression\";\n  }\n  \n  toJson(): object {\n    return {\n      \"ChainedComparison\": {\n        \"operands\": toJsonArray(this.operands),\n        \"operators\": tokensToJsonArray(this.operators)\n      }\n    }\n  }\n}\n\nexport class LogicExpr implements Expression {\n  constructor(public left: Expression, public operator: Token, public right: Expression) {}\n  \n  location(): SrcLocation {\n    return this.left.location().upTo(this.right.location());\n  }\n\n  description(): string {\n    return \"Logic Expression\";\n  }\n\n  toJson(): object {\n    return {\n      \"LogicExpr\": {\n        \"left\": this.left.toJson(),\n        \"operator\": TokenType[this.operator.tokenType],\n        \"right\": this.right.toJson()\n      }\n    }\n  }\n}\n\nexport class UnaryExpr implements Expression {\n  constructor(public operator: Token, public expr: Expression) {}\n\n  location(): SrcLocation {\n    return this.operator.location.upTo(this.expr.location());\n  }\n\n  description(): string {\n    return \"Unary Expression\";\n  }\n\n  toJson(): object {\n    return {\n      \"UnaryExpr\": {\n        \"operator\": TokenType[this.operator.tokenType],\n        \"expr\": this.expr.toJson()\n      }\n    }\n  }\n}\n\nexport class Literal implements Expression {\n  constructor(public value: any, private fullLocation: SrcLocation) {}\n  \n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n\n  description(): string {\n    return \"Literal\";\n  }\n\n  toJson(): object {\n    return {\n      \"Literal\": {\n        \"value\": this.value\n      }\n    }\n  }\n}\n\nexport class GroupingExpr implements Expression {\n  constructor(public expr: Expression, private fullLocation: SrcLocation) {}\n  \n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n\n  description(): string {\n    return \"Grouping Expression\";\n  }\n\n  toJson(): object {\n    return {\n      \"GroupingExpr\": {\n        \"expr\": this.expr.toJson()\n      }\n    }\n  }\n}\n\nexport class IdentifierExpr implements Expression {\n  constructor(public identifier: Identifier) {}\n  \n  location(): SrcLocation {\n    return this.identifier.location;\n  }\n\n  description(): string {\n    return \"Identifier\";\n  }\n\n  toJson(): object {\n    return {\n      \"IdentifierExpr\": {\n        \"identifier\": this.identifier.value\n      }\n    }\n  }\n}\n\nexport class FunctionCallExpr implements Expression {\n  \n  constructor(public callTarget: Expression, public args: Expression[], private fullLocation: SrcLocation) {}\n\n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n\n  description(): string {\n    return \"Function Call Expression\";\n  }\n\n  toJson(): object {\n    return {\n      \"FunctionCallExpr\": {\n        \"callTarget\": this.callTarget.toJson(),\n        \"args\": toJsonArray(this.args)\n      }\n    }\n  }\n}\n\nexport class ListExpr implements Expression {\n  \n  constructor(public elements: Expression[], private fullLocation: SrcLocation) {}\n\n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n\n  description(): string {\n    return \"List Expression\";\n  }\n\n  toJson(): object {\n    return {\n      \"ListExpr\": {\n        \"elements\": toJsonArray(this.elements)\n      }\n    }\n  }\n}\n\nexport class MapExpr implements Expression {\n  \n  constructor(public elements: Map<Expression, Expression>, private fullLocation: SrcLocation) {}\n\n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n\n  description(): string {\n    return \"Map Expression\";\n  }\n\n  toJson(): object {\n    const entries = []\n    for (let [key, value] of this.elements) {\n      entries.push({\"key\": key, \"value\": value})\n    }\n    return {\n      \"MapExpr\": {\n        \"elements\": entries\n      }\n    }\n  }\n}\n\nexport class IndexedAccessExpr implements Expression {\n  constructor(public accessTarget: Expression, public indexExpr: Expression, private fullLocation: SrcLocation) {}\n  \n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n\n  description(): string {\n    return \"Indexed Access\";\n  }\n\n  toJson(): object {\n    return {\n      \"IndexedAccessExpr\": {\n        \"accessTarget\": this.accessTarget.toJson(),\n        \"indexExpr\": this.indexExpr.toJson()\n      }\n    }\n  }\n}\n\nexport class ListSlicingExpr implements Expression {\n  constructor(public listTarget: Expression, public start: OptExpression, public stop: OptExpression, private fullLocation: SrcLocation) {}\n  \n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n  description(): string {\n    return \"List Slicing\";\n  }\n  toJson(): object {\n    return {\n      \"ListSlicingExpr\": {\n        \"listTarget\": this.listTarget.toJson(),\n        \"start\": this.start ? this.start.toJson() : undefined,\n        \"stop\": this.stop ? this.stop.toJson() : undefined\n      }\n    }\n  }\n}\n\nexport class DotAccessExpr implements Expression {\n  constructor(public accessTarget: Expression, public property: Identifier) {}\n  \n  location(): SrcLocation {\n    return this.accessTarget.location().upTo(this.property.location);\n  }\n\n  description(): string {\n    return \"Property Access\";\n  }\n  \n  toJson(): object {\n    return {\n      \"DotAccessExpr\": {\n        \"accessTarget\": this.accessTarget.toJson(),\n        \"property\": this.property.value\n      }\n    }\n  }\n}\n\nexport class Argument {\n  constructor(public name: string, public defaultValue: DefaultArgValue, private fullLocation: SrcLocation) {}\n  \n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n\n  toJson(): object {\n    return {\n      \"Argument\": {\n        \"name\": this.name,\n        \"defaultValue\": this.defaultValue ? this.defaultValue.toJson() : \"(undefined)\"\n      }\n    }\n  }\n}\n\nexport class FunctionBodyExpr implements Expression {\n  \n  constructor(public args: Argument[], public statements: Statement[], private fullLocation: SrcLocation) {}\n\n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n\n  description(): string {\n    return \"Function Body\";\n  }\n\n  toJson(): object {\n    return {\n      \"FunctionBodyExpr\": {\n        \"args\": toJsonArray(this.args),\n        \"statements\": toJsonArray(this.statements)\n      }\n    }\n  }\n}\n\nexport class FunctionRefExpr implements Expression {\n  constructor(public refTarget: Expression, private fullLocation: SrcLocation)  {}\n  \n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n  description(): string {\n    return \"Function Reference\";\n  }\n  toJson(): object {\n    return {\n      \"FunctionRefExpr\": {\n        \"refTarget\": this.refTarget.toJson()\n      }\n    }\n  }\n}\n\nexport class SelfExpr implements Expression {\n  constructor(private fullLocation: SrcLocation) {}\n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n  description(): string {\n    return \"Self Expression\";\n  }\n  toJson(): object {\n    return {\n      \"SelfExpr\": {}\n    }\n  }\n}\n\nexport class SuperExpr implements Expression {\n  constructor(private fullLocation: SrcLocation) {}\n  location(): SrcLocation {\n    return this.fullLocation;\n  }\n  description(): string {\n    return \"Super Expression\";\n  }\n  toJson(): object {\n    return {\n      \"SuperExpr\": {}\n    }\n  }\n}", "\nexport enum BC {\n  // Push primitive value to stack\n  PUSH,\n\n  // Resolve variable and push value to stack\n  EVAL_ID,\n\n  // Perform indexed access (on map/list) using brackets, lile myCollection[23]\n  INDEXED_ACCESS,\n  // Access property using \"dot-notation\", as in myMap.myProperty\n  DOT_ACCESS,\n  // Access property at \"super\" using \"dot-notation\", as in super.myProperty\n  SUPER_DOT_ACCESS,\n\n  // Perform a slice on a sequence (List or String, NOT Map)\n  SLICE_SEQUENCE,\n\n  // Assign value to local variable\n  ASSIGN_LOCAL,\n  // Assign value using indexed access, like myFoo[key] = value\n  ASSIGN_INDEXED,\n  // Assign property using dot-notation, like myMap.property = value\n  DOT_ASSIGN,\n\n  // Various forms of math-assignments\n  MATH_ASSIGN_LOCAL,\n  MATH_ASSIGN_INDEXED,\n  MATH_DOT_ASSIGN,\n\n  // Adds two stack values, leaving result in the stack\n  ADD_VALUES,\n\n  // Subtract two stack values, leaving result in the stack\n  SUBTRACT_VALUES,\n\n  MULTIPLY_VALUES,\n  DIVIDE_VALUES,\n  POWER_VALUES,\n  MOD_VALUES,\n\n  SUBTR_N,\n  DIVIDE_N,\n\n  LOGIC_AND_VALUES,\n  LOGIC_OR_VALUES,\n\n  NEGATE_BOOLEAN,\n  NEGATE_NUMBER,\n\n  COMPARE_EQ,\n  COMPARE_NE,\n\n  COMPARE_GE,\n  COMPARE_GT,\n  COMPARE_LE,\n  COMPARE_LT,\n\n  COMPARE_ISA,\n\n  // Build a List from values on the stack\n  // Push resulting List back\n  BUILD_LIST,\n  // Build a Map from values on the stack\n  // Push resulting Map back\n  BUILD_MAP,\n  // Instantiate new Map using `new``\n  NEW_MAP,\n\n  // Perform a \"chained comparison\"\n  CHAINED_COMPARISON,\n\n  JUMP,\n  POP_JUMP_FALSE,\n  JUMP_IF_FALSE,\n  JUMP_IF_TRUE,\n\n  // Call a stand-alone function directly\n  CALL,\n  // Used to call both in indexed form or dot-form (e.g m[\"f\"](p1,p2) or m.f(p1,p2) )\n  PROPERTY_CALL,\n  // Call method at \"super\", using either `super.foo 123` or `super[\"foo\"] 123`\n  SUPER_DOT_CALL,\n  // Invoke the function stored in the func-ref with parameters\n  FUNCREF_CALL,\n\n  RETURN,\n  \n  POP,\n  PRINT_TOP,\n\n  CREATE_FOR_LOOP,\n  ITERATE_FOR_LOOP,\n  BREAK_FOR_LOOP,\n  CONTINUE_FOR_LOOP,\n};\n\nexport function hasCallPotential(op: BC): boolean {\n  return (op === BC.CALL \n    || op === BC.PROPERTY_CALL\n    || op === BC.DOT_ACCESS\n    || op === BC.FUNCREF_CALL\n    || op === BC.EVAL_ID\n    || op === BC.INDEXED_ACCESS\n    || op === BC.SUPER_DOT_ACCESS\n  );\n}", "import { Code } from \"./code\";\nimport { Context } from \"./context\";\n\nexport class FuncDefArg {\n\n  readonly name: string;\n  readonly defaultValue: any | undefined;\n\n  constructor(name: string, defaultValue: any | undefined) {\n    this.name = name;\n    this.defaultValue = defaultValue;\n  }\n\n}\n\nexport class FuncDef {\n\n  readonly arguments: FuncDefArg[];\n\n  readonly argNames: string[];\n  readonly reversedArgNames: string[];\n  readonly effectiveDefaultValues: any[];\n\n  private readonly code: Code | Function;\n\n  // The \"default values\" array has to have the same length s \"arg-names\".\n  // Pass \"undefined\" as the value if it has NO default value.\n  constructor(args: FuncDefArg[], code: Code | Function) {\n    this.arguments = args;\n\n    this.argNames = args.map((a) => a.name);\n    this.reversedArgNames = this.argNames.slice().reverse();\n    this.effectiveDefaultValues = args.map((a) => a.defaultValue === undefined ? null : a.defaultValue);\n    this.code = code;\n  }\n\n  getLastNEffectiveDefaultValues(amount: number): any[] {\n    return this.effectiveDefaultValues.slice(-amount);\n  }\n\n  isNative(): boolean {\n    return this.code instanceof Function;\n  }\n\n  getCode(): Code {\n    return this.code as Code;\n  }\n\n  getFunction(): Function {\n    return this.code as Function;\n  }\n\n}\n\n// A function definition which is bound to a context at runtime.\n// As such it's ready to run and variables should be able to be \n// resolved even in parent contexts.\nexport class BoundFunction {\n\n  public readonly funcDef: FuncDef;\n  public readonly context: Context;\n\n  constructor(funcDef: FuncDef, context: Context) {\n    this.funcDef = funcDef;\n    this.context = context;\n  }\n\n}", "import { SrcLocation } from \"../parser/commonModel\";\n\nexport type SourceMapEntry = {\n  ipStart: number;\n  ipEnd: number;\n  srcLoc: SrcLocation;\n  isCall: boolean;\n}\n\nexport class SourceMap {\n\n  entries: SourceMapEntry[];\n\n  constructor(public readonly srcFile?: string) {\n    this.entries = [];\n  }\n\n  pushEntry(ipStart: number, ipEnd: number, srcLoc: SrcLocation, isCall: boolean = false) {\n    const entry = {\n      ipStart: ipStart,\n      ipEnd: ipEnd,\n      srcLoc: srcLoc,\n      isCall: isCall,\n    };\n    this.entries.push(entry);\n  }\n\n  pushCall(ipStart: number, ipEnd: number, srcLoc: SrcLocation) {\n    this.pushEntry(ipStart, ipEnd, srcLoc, true);\n  }\n\n  findEntry(ip: number): SourceMapEntry | null {\n    for(let entry of this.entries) {\n      if (ip >= entry.ipStart && ip <= entry.ipEnd) {\n        return entry;\n      }\n    }\n    return null;\n  }\n\n}", "import { BC } from \"./bytecodes\";\nimport { SourceMap } from \"./sourcemap\";\n\nexport class Code {\n\n  opCodes: BC[];\n  // For debugging\n  debugLines: any[];\n  \n  arg1: any[];\n  arg2: any[];\n\n  srcMap: SourceMap;\n  \n  constructor() {\n    this.opCodes = [];\n    this.debugLines = [];\n    this.arg1 = [];\n    this.arg2 = [];\n    this.srcMap = new SourceMap();\n  }\n\n  push(opCode: BC, arg1: any = undefined, arg2: any = undefined) {\n    this.opCodes.push(opCode);\n    this.arg1.push(arg1);\n    this.arg2.push(arg2);\n    this.pushDebugLine(opCode, arg1, arg2);\n  }\n\n  private pushDebugLine(opCode: BC, arg1: any, arg2: any) {\n    const debugCode = [BC[opCode]];\n    if (arg1 !== undefined) debugCode.push(arg1);\n    if (arg2 !== undefined) debugCode.push(arg2);\n    this.debugLines.push(debugCode);\n  }\n\n}", "import { SrcLocation } from \"../parser/commonModel\";\nimport { BC, hasCallPotential } from \"../vm/bytecodes\";\nimport { Code } from \"../vm/code\";\nimport { SourceMap } from \"../vm/sourcemap\";\n\nexport class AddrLabel {\n  constructor(public readonly idx: number) {\n  }\n}\n\nexport class CodeBuilder {\n\n  prg: Code;\n  ip: number;\n  addresses: Map<AddrLabel, number>;\n  unresolvedIdx = 0;\n  unresolved: number[];\n\n  srcMapIpStart: number;\n  srcMap: SourceMap;\n\n  constructor(public readonly srcFile?: string) {\n    this.prg = new Code();\n    this.ip = 0;\n    this.addresses = new Map();\n    this.unresolved = [];\n\n    this.srcMapIpStart = -1;\n    this.srcMap = new SourceMap(srcFile);\n  }\n\n  push(opCode: BC, arg1: any = undefined, arg2: any = undefined) {\n    this.prg.push(opCode, arg1, arg2);\n    this.ip++;\n  }\n  \n  push_unresolved(opCode: BC, arg1: any = undefined, arg2: any = undefined) {\n    if (!(arg1 instanceof AddrLabel) && !(arg2 instanceof AddrLabel)) {\n      throw new Error(\"Expected one of the parameters to be an address label\");\n    }\n    this.prg.push(opCode, arg1, arg2);\n    this.unresolved.push(this.ip);\n    this.ip++;\n  }\n\n  newLabel() {\n    const addLabel = new AddrLabel(this.unresolvedIdx);\n    this.unresolvedIdx += 1;\n    return addLabel;\n  }\n\n  startMapEntry() {\n    this.srcMapIpStart = this.ip;\n  }\n\n  endMapEntry(srcLoc: SrcLocation) {\n    const ipStart = this.srcMapIpStart;\n    const ipEnd = this.ip - 1;\n    if (ipStart < 0) {\n      throw new Error(\"No starting map-entry\");\n    }\n    // Check if the range has a call within\n    // If so, mark as step-in-able\n    const hasCall = this.containsCall(ipStart, ipEnd);\n    // Create entry\n    if (hasCall) {\n      this.srcMap.pushCall(ipStart, ipEnd, srcLoc);\n    } else {\n      this.srcMap.pushEntry(ipStart, ipEnd, srcLoc);\n    }\n    this.srcMapIpStart = -1;\n  }\n\n  containsCall(ipStart: number, ipEnd: number): boolean {\n    for(let idx = ipStart; idx <= ipEnd; idx++) {\n      const opCode = this.prg.opCodes[idx];\n      if (hasCallPotential(opCode)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  define_address(label: AddrLabel) {\n    this.addresses.set(label, this.ip);\n  }\n\n  build(): Code {\n    this.resolveAddresses()\n    const code = this.prg;\n    code.srcMap = this.srcMap;\n    return code;\n  }\n\n  private resolveAddresses() {\n    const resolveAddr = (uaddr: number, argArray: Array<any>) => {\n      let label = argArray[uaddr];\n      if (label instanceof AddrLabel) {\n        let prgAddr = this.addresses.get(label);\n        if (prgAddr === undefined) {\n          throw new Error(`No address for label ${label} at address ${uaddr}`);\n        }\n        // Replace with resolved address\n        argArray[uaddr] = prgAddr;\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n\n    for (let uaddr of this.unresolved) {\n      let resolvedCount = 0;\n      resolvedCount += resolveAddr(uaddr, this.prg.arg1);\n      resolvedCount += resolveAddr(uaddr, this.prg.arg2);\n      if (resolvedCount === 0) {\n        throw new Error(\"No addresses resolved for \" + uaddr);\n      }\n    }\n  }\n\n}", "\nexport class NotImplemented extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n// Ideally these should not happen.\n// Either a runtime-error should be thrown\n// or the parser revised to catch errors\n// earlier.\nexport class CompileTimeError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}", "import { Expression, Literal, IdentifierExpr, SelfExpr, SuperExpr, BinaryExpr, UnaryExpr, ChainedComparisonExpr, LogicExpr, GroupingExpr, ListExpr, MapExpr, IndexedAccessExpr, DotAccessExpr, ListSlicingExpr, FunctionCallExpr, FunctionRefExpr, FunctionBodyExpr } from \"../parser/parserModel\";\nimport { TokenType } from \"../parser/tokenTypes\";\nimport { BC } from \"../vm/bytecodes\";\nimport { FuncDef, FuncDefArg } from \"../vm/funcdef\";\nimport { CodeBuilder } from \"./codebuilder\";\nimport { Compiler } from \"./compiler\";\nimport { NotImplemented, CompileTimeError } from \"./compilerModel\";\n\nexport class ExpressionCompilerContext {\n  constructor(public readonly isFuncRef: boolean = false, public readonly isStatement: boolean = false) {\n  }\n  enterFunctionReference(): ECContext {\n    const newContext = new ExpressionCompilerContext(true, this.isStatement);\n    return newContext;\n  }\n  enterStatement(): ECContext {\n    const newContext = new ExpressionCompilerContext(this.isFuncRef, true);\n    return newContext;   \n  }\n}\n\nexport type ECContext = ExpressionCompilerContext;\n\nexport class ExpressionCompiler {\n\n  constructor(private builder: CodeBuilder) { }\n\n  compileExpression(e: Expression, context: ECContext | null = null) {\n    const b = this.builder;\n    context = context == null ? new ExpressionCompilerContext() : context;\n\n    if (e instanceof Literal) {\n      b.push(BC.PUSH, e.value)\n    } else if (e instanceof IdentifierExpr) {\n      this.compileIdentifierExpr(e, context);\n    } else if (e instanceof SelfExpr) {\n      this.compileSelfExpr();\n    } else if (e instanceof SuperExpr) {\n      this.compileSuperExpr();\n    } else if (e instanceof BinaryExpr) {\n      this.compileBinaryExpression(e);\n    } else if (e instanceof UnaryExpr) {\n      this.compileUnaryExpression(e);\n    } else if (e instanceof ChainedComparisonExpr) {\n      this.compileChainedComparisonExpression(e);\n    } else if (e instanceof LogicExpr) {\n      this.compileLogicExpression(e);\n    } else if (e instanceof GroupingExpr) {\n      this.compileExpression(e.expr, context);\n    } else if (e instanceof ListExpr) {\n      this.compileListExpression(e);\n    } else if (e instanceof MapExpr) {\n      this.compileMapExpression(e);\n    } else if (e instanceof IndexedAccessExpr) {\n      this.compileIndexedAccessExpression(e, context);\n    } else if (e instanceof DotAccessExpr) {\n      this.compileDotAccessExpression(e, context);\n    } else if (e instanceof ListSlicingExpr) {\n      this.compileListSlicingExpression(e);\n    } else if (e instanceof FunctionCallExpr) {\n      this.compileFuncCallExpr(e.callTarget, e.args, context);\n    } else if (e instanceof FunctionRefExpr) {\n      this.compileFuncRefExpression(e, context);\n    } else if (e instanceof FunctionBodyExpr) {\n      this.compileFunctionBodyExpression(e);\n    } else {\n      throw new NotImplemented(\"Expression type not yet supported: \" + e.description())\n    }\n  }\n\n  compileIdentifierExpr(e: IdentifierExpr, context: ECContext) {\n    this.builder.push(BC.EVAL_ID, e.identifier.value, context.isFuncRef);\n  }\n\n  compileSelfExpr() {\n    this.builder.push(BC.EVAL_ID, \"self\");\n  }\n\n  compileSuperExpr() {\n    this.builder.push(BC.EVAL_ID, \"super\");\n  }\n\n  compileFuncCall(callTarget: Expression, args: Expression[]) {\n    const context = new ExpressionCompilerContext();\n    this.compileFuncCallExpr(callTarget, args, context);\n  }\n\n  compileFuncCallExpr(callTarget: Expression, params: Expression[], context: ECContext) {\n    const pushParams = () => {\n      // Push parameters\n      for (let param of params) {\n        this.compileExpression(param)\n      }\n    };\n    const paramCount = params.length;\n    // Resolve and call target\n    if (callTarget instanceof IdentifierExpr) {\n      const identifier = callTarget.identifier.value;\n      pushParams();\n      this.builder.push(BC.CALL, identifier, paramCount);\n    } else if(callTarget instanceof DotAccessExpr \n        && callTarget.accessTarget instanceof SuperExpr) {\n      const identifier = callTarget.property.value;\n      // Push property\n      this.builder.push(BC.PUSH, identifier);\n      // Push params\n      pushParams();\n      // Push opcode\n      this.builder.push(BC.SUPER_DOT_CALL, paramCount);\n    } else if(callTarget instanceof DotAccessExpr) {\n      const identifier = callTarget.property.value;\n      // Push call target\n      this.compileExpression(callTarget.accessTarget);\n      // Push property\n      this.builder.push(BC.PUSH, identifier);\n      // Push params\n      pushParams();\n      // Push opcode\n      this.builder.push(BC.PROPERTY_CALL, paramCount);\n    } else if(callTarget instanceof IndexedAccessExpr\n        && callTarget.accessTarget instanceof SuperExpr) {\n      // Push property\n      this.compileExpression(callTarget.indexExpr);\n      // Push params\n      pushParams();\n      // Push opcode\n      this.builder.push(BC.SUPER_DOT_CALL, paramCount);\n    } else if(callTarget instanceof IndexedAccessExpr) {\n      // Push call target\n      this.compileExpression(callTarget.accessTarget);\n      // Push property\n      this.compileExpression(callTarget.indexExpr);\n      // Push params\n      pushParams();\n      // Push opcode\n      this.builder.push(BC.PROPERTY_CALL, paramCount);\n    } else if(callTarget instanceof FunctionCallExpr) {\n      const ctx = context.enterFunctionReference();\n      this.compileExpression(callTarget, ctx);\n      pushParams();\n      this.builder.push(BC.FUNCREF_CALL, paramCount);\n    } else {\n      throw new CompileTimeError(`Invalid call target: ${callTarget.toJson()}`)\n    }\n  }\n\n  private compileBinaryExpression(e: BinaryExpr) {\n    this.compileExpression(e.left)\n    this.compileExpression(e.right)\n    switch (e.operator.tokenType) {\n      case TokenType.OP_EQUALS: {\n        this.builder.push(BC.COMPARE_EQ)\n        break;\n      }\n      case TokenType.OP_NOT_EQUALS: {\n        this.builder.push(BC.COMPARE_NE)\n        break;\n      }\n      case TokenType.OP_PLUS: {\n        this.builder.push(BC.ADD_VALUES)\n        break;\n      }\n      case TokenType.OP_MINUS: {\n        this.builder.push(BC.SUBTRACT_VALUES)\n        break;\n      }\n      case TokenType.OP_MULT: {\n        this.builder.push(BC.MULTIPLY_VALUES)\n        break;\n      }\n      case TokenType.OP_DIV: {\n        this.builder.push(BC.DIVIDE_VALUES)\n        break;\n      }\n      case TokenType.OP_POW: {\n        this.builder.push(BC.POWER_VALUES)\n        break;\n      }\n      case TokenType.OP_MOD: {\n        this.builder.push(BC.MOD_VALUES)\n        break;\n      }\n      case TokenType.OP_LESS_EQUALS: {\n        this.builder.push(BC.COMPARE_LE)\n        break;\n      }\n      case TokenType.OP_LESS: {\n        this.builder.push(BC.COMPARE_LT)\n        break;\n      }\n      case TokenType.OP_GREATER_EQUALS: {\n        this.builder.push(BC.COMPARE_GE)\n        break;\n      }\n      case TokenType.OP_GREATER: {\n        this.builder.push(BC.COMPARE_GT)\n        break;\n      }\n      case TokenType.OP_ISA: {\n        this.builder.push(BC.COMPARE_ISA)\n        break;\n      }\n      default:\n        throw new NotImplemented(\"Operator not implemented: \" + TokenType[e.operator.tokenType])\n    }\n  }\n\n  private compileUnaryExpression(e: UnaryExpr) {\n    // Compile expression\n    this.compileExpression(e.expr);\n    // Push operator\n    switch (e.operator.tokenType) {\n      case TokenType.OP_NOT: {\n        this.builder.push(BC.NEGATE_BOOLEAN);\n        break;\n      }\n      case TokenType.OP_MINUS: {\n        this.builder.push(BC.NEGATE_NUMBER);\n        break;\n      }\n      case TokenType.KW_NEW: {\n        this.builder.push(BC.NEW_MAP);\n        break;\n      }\n      default: {\n        throw new CompileTimeError(\"Invalid unary operator. Token type: \" + e.operator.tokenType);\n      }\n    }\n  }\n\n  private compileChainedComparisonExpression(e: ChainedComparisonExpr) {\n    // Compile and push expressions\n    for (let operandExpression of e.operands) {\n      this.compileExpression(operandExpression);\n    }\n    // Push operators\n    for (let operator of e.operators) {\n      switch (operator.tokenType) {\n        case TokenType.OP_EQUALS: {\n          this.builder.push(BC.PUSH, \"==\");\n          break;\n        }\n        case TokenType.OP_NOT_EQUALS: {\n          this.builder.push(BC.PUSH, \"!=\");\n          break;\n        }\n        case TokenType.OP_GREATER: {\n          this.builder.push(BC.PUSH, \">\");\n          break;\n        }   \n        case TokenType.OP_GREATER_EQUALS: {\n          this.builder.push(BC.PUSH, \">=\");\n          break;\n        } \n        case TokenType.OP_LESS: {\n          this.builder.push(BC.PUSH, \"<\");\n          break;\n        }\n        case TokenType.OP_LESS_EQUALS: {\n          this.builder.push(BC.PUSH, \"<=\");\n          break;\n        }\n        default: {\n          throw new CompileTimeError(\"Invalid operator found\");\n        }\n      }\n    }\n    // Push special opcode\n    const pairCount = e.operators.length;\n    this.builder.push(BC.CHAINED_COMPARISON, pairCount);\n  }\n\n  private compileLogicExpression(e: LogicExpr) {\n    // Determine type\n    const isAnd = e.operator.tokenType == TokenType.OP_AND;\n    const isOr = e.operator.tokenType == TokenType.OP_OR;\n    if (!(isAnd || isOr)) {\n      throw new CompileTimeError(\"Invalid logic operator: must be either AND or OR\");\n    }\n    // Used to short-circuit when further evaluation is not needed.\n    // For example \"true or something-else\" or \"false and something-else\".\n    // This is not only an optimization but expected behaviour.\n    const shortCircuitAddr = this.builder.newLabel();\n\n    // Compile expression of the left\n    this.compileExpression(e.left);\n    \n    // Insert short-circuit conditional jump\n    if (isAnd) {\n      this.builder.push_unresolved(BC.JUMP_IF_FALSE, shortCircuitAddr);\n    } else {\n      this.builder.push_unresolved(BC.JUMP_IF_TRUE, shortCircuitAddr);\n    }\n\n    // The following only executes in case of no short-circuit\n\n    // Compile expression on the right\n    this.compileExpression(e.right);\n\n    if (isAnd) {\n      this.builder.push(BC.LOGIC_AND_VALUES)\n    } else {\n      this.builder.push(BC.LOGIC_OR_VALUES)\n    }\n\n    // Address to jump to in case of short-circuiting (skipping evaluating the\n    // right expression)\n    this.builder.define_address(shortCircuitAddr);\n  }\n\n  private compileListExpression(e: ListExpr) {\n    const elementCount = e.elements.length;\n    // Compile all elements\n    for (let elementExpr of e.elements) {\n      this.compileExpression(elementExpr);\n    }\n    // Issue opcode to build list\n    this.builder.push(BC.BUILD_LIST, elementCount);\n  }\n\n  private compileMapExpression(e: MapExpr) {    \n    const elementCount = e.elements.size;\n    // Compile all key-value pairs\n    for (let [keyExpr, valueExpr] of e.elements) {\n      this.compileExpression(keyExpr);\n      this.compileExpression(valueExpr);\n    }\n    // Issue opcode to build map\n    this.builder.push(BC.BUILD_MAP, elementCount);\n  }\n\n  private compileIndexedAccessExpression(e: IndexedAccessExpr, context: ECContext) {\n    this.compileExpression(e.accessTarget);\n    this.compileExpression(e.indexExpr);\n    // If the indexed-access takes place as a statement INVOKE the function\n    // Otherwise return the function value\n    let isFuncRef: boolean;\n    if (context.isStatement) {\n      isFuncRef = false;\n    } else {\n      isFuncRef = true;\n    }\n    this.builder.push(BC.INDEXED_ACCESS, isFuncRef);\n  }\n\n  private compileDotAccessExpression(e: DotAccessExpr, context: ECContext) {\n    if (e.accessTarget instanceof SuperExpr) {\n      this.builder.push(BC.SUPER_DOT_ACCESS, e.property.value, context.isFuncRef);  \n    } else {\n      this.compileExpression(e.accessTarget);\n      this.builder.push(BC.DOT_ACCESS, e.property.value, context.isFuncRef);\n    }\n  }\n\n  private compileFuncRefExpression(e: FunctionRefExpr, context: ECContext) {\n    const functionReferenceContext = context.enterFunctionReference();\n    // Compile the reference-target expression, but in the context\n    // of a function reference.\n    // This should affect evaluation of single identifiers,\n    // indexed-access and dot-access. If the result of these operations\n    // is a bound-function, then it should be left in the stack as a value\n    // and not immediately evaluated. Anything else can be evaluated as is.\n    this.compileExpression(e.refTarget, functionReferenceContext);\n  }\n\n  private compileListSlicingExpression(e: ListSlicingExpr) {\n    // Push list expression\n    this.compileExpression(e.listTarget);\n    // Push start value\n    if (e.start) {\n      this.compileExpression(e.start);\n    } else {\n      this.builder.push(BC.PUSH, null);\n    }\n    // Push stop value\n    if (e.stop) {\n      this.compileExpression(e.stop);\n    } else {\n      this.builder.push(BC.PUSH, null);\n    }\n    // Push opcode\n    this.builder.push(BC.SLICE_SEQUENCE);\n  }\n\n  private compileFunctionBodyExpression(e: FunctionBodyExpr) {\n    // Resolve arguments (names / default values)\n    const args = [];\n    for (let arg of e.args) {\n      if (arg.defaultValue) {\n        args.push(new FuncDefArg(arg.name, arg.defaultValue.value));\n      } else {\n        args.push(new FuncDefArg(arg.name, undefined));\n      }\n    }\n    // Compile code\n    const funcCompiler = new Compiler(e.statements);\n    const funcCode = funcCompiler.compileFunctionBody();\n    // Build and push function definition\n    let funcDef = new FuncDef(args, funcCode);\n    this.builder.push(BC.PUSH, funcDef);\n  }\n\n}", "\n// Not to be confused with a runtime-context. This refers to where in the \n// CODE (statically speaking) we are placed. Depending on that, certain \n\nimport { Statement, ExpressionStatement, AssignmentStatement, MathAssignmentStatement, ReturnStatement, IfStatement, WhileStatement, ForStatement, BreakStatement, ContinueStatement, FunctionCallStatement, Expression, IdentifierExpr, IndexedAccessExpr, DotAccessExpr } from \"../parser/parserModel\";\nimport { BC } from \"../vm/bytecodes\";\nimport { AddrLabel, CodeBuilder } from \"./codebuilder\";\nimport { ExpressionCompiler, ExpressionCompilerContext } from \"./expressionCompiler\";\n\n// things are allowed or not.\nexport class CompilerContext {\n\n  parent: CompilerContext | undefined = undefined;\n\n  constructor() {\n    this.parent = undefined;\n  }\n\n  insideWhile(): boolean {\n    if (this.parent) {\n      return this.parent.insideWhile();\n    } else {\n      return false\n    }\n  }\n  insideForLoop(): boolean {\n    if (this.parent) {\n      return this.parent.insideForLoop();\n    } else {\n      return false\n    }  \n  }\n  insideFunctionBody(): boolean {\n    if (this.parent) {\n      return this.parent.insideFunctionBody();\n    } else {\n      return false\n    }  \n  }\n  getForLoopNr(): number {\n    if (this.parent) {\n      return this.parent.getForLoopNr();\n    } else {\n      return 0\n    }\n  }\n}\n\nclass WhileContext extends CompilerContext {\n\n  public readonly startLabel: AddrLabel;\n  public readonly endLabel: AddrLabel;\n\n  constructor(parent: CompilerContext, startLabel: AddrLabel, endLabel: AddrLabel) {\n    super();\n    this.parent = parent;\n    this.startLabel = startLabel;\n    this.endLabel = endLabel;\n  }\n  insideWhile(): boolean {\n    return true;\n  }\n}\n\nclass ForLoopContext extends CompilerContext {\n  constructor(parent: CompilerContext) {\n    super();\n    this.parent = parent;\n  }\n  insideForLoop(): boolean {\n    return true;\n  }\n  getForLoopNr(): number {\n    if (this.parent) {\n      // Increase for-loop-nr by one\n      return 1 + this.parent.getForLoopNr();\n    } else {\n      throw new Error(\"Parent not set\");\n    }\n  }\n}\n\nexport class FunctionBodyContext extends CompilerContext {\n  constructor() {\n    super();\n  }\n  insideFunctionBody(): boolean {\n    return true;\n  }\n}\n\nexport class StatementCompiler {\n\n  constructor(private builder: CodeBuilder, private expressionCompiler: ExpressionCompiler) { }\n\n  compileStatements(statements: Statement[], context: CompilerContext) {\n    for(const s of statements) {\n      this.compileStatement(s, context)\n    } \n  }\n\n  private compileStatement(s: Statement, context: CompilerContext) {\n    if (s instanceof ExpressionStatement) {\n      this.compileExpressionStatement(s);\n    } else if (s instanceof AssignmentStatement) {\n      this.compileAssignmentStatement(s);\n    } else if (s instanceof MathAssignmentStatement) {\n      this.compileMathAssignmentStatement(s);\n    } else if (s instanceof ReturnStatement) {\n      this.compileReturnStatement(s);\n    } else if (s instanceof IfStatement) {\n      this.compileIfStatement(s, context);  \n    } else if (s instanceof WhileStatement) {\n      this.compileWhileStatement(s, context);  \n    } else if (s instanceof ForStatement) {\n      this.compileForLoopStatement(s, context);\n    } else if (s instanceof BreakStatement) {\n      this.compileBreakStatement(s, context);\n    } else if (s instanceof ContinueStatement) {\n      this.compileContinueStatement(s, context);  \n    } else if (s instanceof FunctionCallStatement) {\n      this.compileFunctionCallStatement(s);\n    } else {\n      throw new Error(\"Compilation of statement not implemented: \" + s.description())\n    }\n  }\n\n  private compileExpression(e: Expression) {\n    this.expressionCompiler.compileExpression(e);\n  }\n\n  private compileExpressionStatement(s: ExpressionStatement) {\n    let exprCompilerContext = new ExpressionCompilerContext();\n    // Mark context as \"statement\". Let the expression compiler\n    // know that the expression is an statement-expression.\n    // MiniScript sometimes behaves differently in this case. \n    exprCompilerContext = exprCompilerContext.enterStatement();\n    // Compile expression and discard result\n    this.builder.startMapEntry();    \n    this.expressionCompiler.compileExpression(s.expression, exprCompilerContext);\n    this.builder.endMapEntry(s.location());\n    this.builder.push(BC.POP);\n  }\n\n  private compileAssignmentStatement(s: AssignmentStatement) {\n    this.builder.startMapEntry();\n    // Push bytecodes to complete the assignment\n    const target = s.target;\n    if (target instanceof IdentifierExpr) {\n      this.compileExpression(s.value);\n      this.builder.push(BC.ASSIGN_LOCAL, target.identifier.value);\n    } else if (target instanceof IndexedAccessExpr) {\n      this.compileExpression(target.indexExpr);\n      this.compileExpression(s.value);\n      this.compileExpression(target.accessTarget);\n      this.builder.push(BC.ASSIGN_INDEXED);\n    } else if (target instanceof DotAccessExpr) {\n      // Map to assign into\n      this.compileExpression(s.value);\n      this.compileExpression(target.accessTarget);\n      this.builder.push(BC.DOT_ASSIGN, target.property.value);   \n    } else {\n      throw new Error(\"Assignment target not yet supported: \" + s.target.description());\n    }\n    this.builder.endMapEntry(s.location());\n  }\n\n  private compileMathAssignmentStatement(s: MathAssignmentStatement) {\n    this.builder.startMapEntry();\n    // Push bytecodes to complete the assignment\n    const target = s.target;\n    if (target instanceof IdentifierExpr) {\n      this.compileExpression(s.value);\n      this.builder.push(BC.MATH_ASSIGN_LOCAL, target.identifier.value, s.opToken);\n    } else if (target instanceof IndexedAccessExpr) {\n      this.compileExpression(target.accessTarget);\n      this.compileExpression(target.indexExpr);\n      this.compileExpression(s.value);\n      this.builder.push(BC.MATH_ASSIGN_INDEXED, s.opToken);\n    } else if (target instanceof DotAccessExpr) {\n      this.compileExpression(target.accessTarget);\n      this.compileExpression(s.value);\n      this.builder.push(BC.MATH_DOT_ASSIGN, target.property.value, s.opToken);   \n    } else {\n      throw new Error(\"Assignment target not yet supported: \" + s.target.description());\n    }\n    this.builder.endMapEntry(s.location());\n  }\n\n  private compileReturnStatement(s: ReturnStatement) {\n    this.builder.startMapEntry();\n    if (s.optValue) {\n      this.compileExpression(s.optValue)\n    } else {\n      // Push a \"null\" value if not explicitly returning anything\n      this.builder.push(BC.PUSH, null);\n    }\n    this.builder.push(BC.RETURN);\n    this.builder.endMapEntry(s.location());\n  }\n\n  private compileIfStatement(s: IfStatement, context: CompilerContext) {\n    // End of only the if / then part\n    const endIfThenLabel = this.builder.newLabel();\n    // End of the whole if / then / else-ifs block\n    const endFullIfBlockLabel = this.builder.newLabel();\n    \n    this.builder.startMapEntry();\n    \n    this.compileExpression(s.ifBranch.condition);\n    this.builder.push_unresolved(BC.POP_JUMP_FALSE, endIfThenLabel);\n\n    this.builder.endMapEntry(s.ifBranch.condition.location());\n\n    this.compileStatements(s.ifBranch.statements, context);\n    this.builder.push_unresolved(BC.JUMP, endFullIfBlockLabel);\n    this.builder.define_address(endIfThenLabel);\n\n    for (let elseIf of s.elseIfs) {\n      let elseIfLabel = this.builder.newLabel();\n      this.builder.startMapEntry();\n      this.compileExpression(elseIf.condition)\n      this.builder.push_unresolved(BC.POP_JUMP_FALSE, elseIfLabel)\n      this.builder.endMapEntry(elseIf.condition.location());\n\n      this.compileStatements(elseIf.statements, context);\n      this.builder.push_unresolved(BC.JUMP, endFullIfBlockLabel);\n      this.builder.define_address(elseIfLabel);\n    }\n\n    if (s.elseBranch.length > 0) {\n      this.compileStatements(s.elseBranch, context);\n    }\n\n    this.builder.define_address(endFullIfBlockLabel);\n  }\n\n  private compileWhileStatement(s: WhileStatement, context: CompilerContext) {\n    const startWhileLabel = this.builder.newLabel();\n    const endWhileLabel = this.builder.newLabel();\n\n    // While header\n    this.builder.startMapEntry();\n    this.builder.define_address(startWhileLabel);\n    this.compileExpression(s.condition);\n    this.builder.push_unresolved(BC.POP_JUMP_FALSE, endWhileLabel);\n    this.builder.endMapEntry(s.condition.location());\n\n    // Statements\n    const whileContext = new WhileContext(context, startWhileLabel, endWhileLabel);\n    this.compileStatements(s.statements, whileContext);\n\n    // Jump to start (loop)\n    this.builder.push_unresolved(BC.JUMP, startWhileLabel);\n\n    // Define end\n    this.builder.define_address(endWhileLabel);\n  }\n\n  private compileForLoopStatement(s: ForStatement, context: CompilerContext) {\n    const startForLoopLabel = this.builder.newLabel();\n    const endForLoopLabel = this.builder.newLabel();\n    const forLoopContext = new ForLoopContext(context);\n    const forLoopNr = forLoopContext.getForLoopNr();\n\n    // For loop DEFINITION (happens only once)\n\n    // Push for-loop local variable name\n    this.builder.push(BC.PUSH, s.loopVar.value);\n    // Push values to iterate over\n    this.compileExpression(s.rangeExpr);\n    // Push end-address (for \"break\" or when over)\n    this.builder.push_unresolved(BC.PUSH, endForLoopLabel);\n    // Push \"header\" address, for new iterations or continues\n    this.builder.push_unresolved(BC.PUSH, startForLoopLabel);\n    // Push opcode to create loop\n    this.builder.push(BC.CREATE_FOR_LOOP, forLoopNr);\n\n    // For header (control jumps here on every iteration)\n    this.builder.startMapEntry();\n    this.builder.define_address(startForLoopLabel);\n    this.builder.push(BC.ITERATE_FOR_LOOP, forLoopNr);\n    this.builder.endMapEntry(s.headerLocation);\n\n    // Statements\n    this.compileStatements(s.statements, forLoopContext);\n\n    // Jump to header (to iterate again)\n    this.builder.push_unresolved(BC.JUMP, startForLoopLabel);\n\n    // Define end\n    this.builder.define_address(endForLoopLabel);\n  }\n\n  private compileBreakStatement(s: BreakStatement, context: CompilerContext) {\n    if (context.insideWhile() && context instanceof WhileContext) {\n      this.builder.startMapEntry();\n      // Jump to end of while\n      this.builder.push_unresolved(BC.JUMP, context.endLabel);\n      this.builder.endMapEntry(s.location());\n    } else if (context.insideForLoop() && context instanceof ForLoopContext) {\n      this.builder.startMapEntry();\n      // Break out of for-loop\n      this.builder.push(BC.BREAK_FOR_LOOP, context.getForLoopNr());\n      this.builder.endMapEntry(s.location());\n    } else {\n      throw new Error(\"break outside while / for loop\");\n    }\n  }\n\n  private compileContinueStatement(s: ContinueStatement, context: CompilerContext) {\n    if (context.insideWhile() && context instanceof WhileContext) {\n      this.builder.startMapEntry();\n      // Jump to start of while\n      this.builder.push_unresolved(BC.JUMP, context.startLabel);\n      this.builder.endMapEntry(s.location());\n    } else if (context.insideForLoop() && context instanceof ForLoopContext) {\n      this.builder.startMapEntry();\n      // Trigger a \"continue\" in for-loop (jump to header address)\n      this.builder.push(BC.CONTINUE_FOR_LOOP, context.getForLoopNr());\n      this.builder.endMapEntry(s.location());\n    } else {\n      throw new Error(\"continue outside while / for loop\");\n    }\n  }\n\n  private compileFunctionCallStatement(s: FunctionCallStatement) {\n    this.builder.startMapEntry();\n    this.expressionCompiler.compileFuncCall(s.callTarget, s.args);\n    this.builder.endMapEntry(s.location());\n    // Discard returned value, since it's a statement\n    this.builder.push(BC.POP);\n  }\n\n}", "import { Statement, ReturnStatement } from \"../parser/parserModel\";\nimport { BC } from \"../vm/bytecodes\";\nimport { Code } from \"../vm/code\";\nimport { FuncDef } from \"../vm/funcdef\";\nimport { CodeBuilder } from \"./codebuilder\";\nimport { ExpressionCompiler } from \"./expressionCompiler\";\nimport { CompilerContext, FunctionBodyContext, StatementCompiler } from \"./statementCompiler\";\n\nexport class Compiler {\n  \n  private readonly builder: CodeBuilder;\n  private readonly statementCompiler: StatementCompiler;\n  private readonly expressionCompiler: ExpressionCompiler;\n\n  constructor(private statements: Statement[], srcFile?: string) {\n    this.builder = new CodeBuilder(srcFile);\n    this.expressionCompiler = new ExpressionCompiler(this.builder);\n    this.statementCompiler = new StatementCompiler(this.builder, this.expressionCompiler);\n  }\n  \n  compile(): Code {\n    const context = new CompilerContext();\n    this.statementCompiler.compileStatements(this.statements, context);\n    //this.builder.push(BC.EXIT);\n    const prg = this.builder.build();\n    return prg\n  }\n\n  compileModuleInvocation(moduleName: string): Code {\n    // Compile statements as if inside a function\n    const context = new FunctionBodyContext();\n    this.statementCompiler.compileStatements(this.statements, context);\n    // Emit a last \"return locals\"\n    this.emitLastReturn(true);\n    const moduleStatements = this.builder.build();\n    // Build an anonymous function-body containing those statements\n    const moduleLoaderBuilder = new CodeBuilder(`${moduleName} (loader)`);\n    const moduleBodyFn = new FuncDef([], moduleStatements);\n    // Push the function-body as a value into the stack\n    moduleLoaderBuilder.push(BC.PUSH, moduleBodyFn);\n    // Execute the function-body pushed the step before.\n    // As a result of this, the stack should have the \"locals\"\n    moduleLoaderBuilder.push(BC.FUNCREF_CALL, 0);\n    // Assign the module-locals to an identifier named after the module\n    // in the current context.\n    moduleLoaderBuilder.push(BC.ASSIGN_LOCAL, moduleName);\n    // Build this and return\n    const runnerCode = moduleLoaderBuilder.build();\n    return runnerCode;\n  }\n\n  compileFunctionBody(): Code {\n    const context = new FunctionBodyContext();\n    this.statementCompiler.compileStatements(this.statements, context);\n    this.emitLastReturn(false);\n    const prg = this.builder.build();\n    return prg\n  } \n\n  private emitLastReturn(inModuleBody: boolean) {\n    // Emit a last \"return null\" statement if the compiled statements\n    // do not end with a \"return XXX\"\n    let emitReturn = true;\n    if (this.statements.length > 0) {\n      const lastStatement = this.statements[this.statements.length - 1];\n      if (lastStatement instanceof ReturnStatement) {\n        emitReturn = false;\n      }\n    }\n    if (emitReturn) {\n      if (inModuleBody) {\n        this.builder.push(BC.EVAL_ID, \"locals\");\n        this.builder.push(BC.RETURN);\n      } else {\n        // Signialize that this is a \"does not return anything\" null \n        // by returning undefined.\n        this.builder.push(BC.PUSH, undefined);\n        this.builder.push(BC.RETURN);\n      }\n    }\n  }\n\n}", "import { Processor } from \"../vm/processor\";\nimport { SourceMapEntry } from \"../vm/sourcemap\";\nimport { Debugger } from \"./debugger\";\n\nexport abstract class Stepper {\n\n  initialCallStackDepth: number;\n  initialEntry: SourceMapEntry | null;\n\n  constructor(protected readonly id: number, protected readonly d: Debugger, protected readonly vm: Processor) {\n    this.initialCallStackDepth = this.vm.savedFrames.count();\n    this.initialEntry = this.d.getCurrentSrcMapEntry();\n  }\n\n  abstract step(): void;\n\n  scheduleNext() {\n    setTimeout(() => {\n      this.step();\n    }, 0)\n  }\n\n  resumeFromSuspension() {\n    this.scheduleNext();\n  }\n\n  finish() {\n    // Advance until we are at a concrete srcMap entry\n    this.d.stepUntilSrcMapEntryFound();\n    this.d.notifyChanges();\n    this.d.removeStepper(this.id);\n  }\n}\n\nexport class StepOverStepper extends Stepper {\n\n  initialCallStackDepth: number;\n  initialEntry: SourceMapEntry | null;\n\n  constructor(id: number, d: Debugger, vm: Processor) {\n    super(id, d, vm);\n    this.initialCallStackDepth = vm.savedFrames.count();\n    this.initialEntry = d.getCurrentSrcMapEntry();\n  }\n\n  step() {\n\n    if (this.vm.isSuspended()) {\n      // Just return, the debugger will be notified\n      // when the Promise is resolved and continue \n      // the process here.\n      return;\n    }\n\n    this.vm.runOneCycle();\n    \n    // If we went \"deeper\" into the call stack, execute cycles until we are \"back\".\n    // Only then compare source locations.\n    const currentCallStackDepth = this.vm.savedFrames.count();\n    if (currentCallStackDepth > this.initialCallStackDepth) {\n      this.scheduleNext();\n      return;\n    }\n\n    if (this.vm.isFinished()) {\n      this.finish();\n      return;\n    }\n\n    const currentEntry = this.d.getCurrentSrcMapEntry();\n    let sourceLocationChanged = false;\n\n    if (this.initialEntry === null && currentEntry !== null) {\n      sourceLocationChanged = true;\n    } else if(this.initialEntry !== null && currentEntry === null) {\n      // Skipping until non-null current-entry is found\n      this.scheduleNext();\n      return;\n    } else if(this.initialEntry !== null && currentEntry !== null) {\n      const initialLoc = this.initialEntry.srcLoc.start.row;\n      const currentLoc = currentEntry.srcLoc.start.row;\n      sourceLocationChanged = (initialLoc !== currentLoc);\n    }\n\n    if (sourceLocationChanged) {\n      this.finish();\n      return;\n    }\n\n    // Otherwise ...\n    this.scheduleNext();\n  }\n\n}\n\nexport class StepIntoStepper extends Stepper {\n\n  initialCount: number;\n\n  constructor(id: number, d: Debugger, vm: Processor) {\n    super(id, d, vm);\n    this.initialCount = this.vm.savedFrames.count();\n  }\n\n  step() {\n    if (this.vm.isSuspended()) {\n      // Just return, the debugger will be notified\n      // when the Promise is resolved and continue \n      // the process here.\n      return;\n    }\n\n    const nextOpIsCall = this.vm.couldResultInCall();\n    this.vm.runOneCycle();\n\n    const currentCount = this.vm.savedFrames.count();\n    if (currentCount > this.initialCount) {\n      // A function call has been made, since a new frame was pushed\n      this.finish();\n      return;\n    } else if (nextOpIsCall && currentCount == this.initialCount) {\n      // A call should have been made, but was not.\n      // Probably because a primitive was called.\n      // Abandon the whole attempt.\n      if (!this.vm.isSuspended()) {\n        // Only finish if the call did not result in an intrinsic\n        // call, which suspended the VM.\n        // In that case we need to continue after that.\n        this.finish();\n      } \n      return;\n    }\n    if (this.vm.isFinished()) {\n      this.finish();\n      return;\n    }\n\n    // Otherwise ...\n    this.scheduleNext();\n  }\n\n}\n\nexport class StepOutStepper extends Stepper {\n\n  initialCount: number;\n\n  constructor(id: number, d: Debugger, vm: Processor) {\n    super(id, d, vm);\n    this.initialCount = this.vm.savedFrames.count();\n  }\n\n  step() {\n    if (this.vm.isSuspended()) {\n      // Just return, the debugger will be notified\n      // when the Promise is resolved and continue \n      // the process here.\n      return;\n    }\n\n    this.vm.runOneCycle();\n\n    const currentCount = this.vm.savedFrames.count();\n\n    if (currentCount < this.initialCount) {\n      // A return from a call has been made, since a frame was removed\n      this.finish();\n      return;\n    }\n    \n    if (this.vm.isFinished()) {\n      this.finish();\n      return;\n    }\n\n    // Otherwise ...\n    this.scheduleNext();\n  }\n\n}", "import { Code } from \"../vm/code\";\nimport { Processor } from \"../vm/processor\";\nimport { SourceMapEntry } from \"../vm/sourcemap\";\nimport { StepIntoStepper, StepOutStepper, StepOverStepper, Stepper } from \"./steppers\";\n\nexport class Debugger {\n\n  private nextStepperId: number = 1;\n  private steppers: Map<number, Stepper>;\n\n  constructor(private vm: Processor) {\n    this.vm.setRunAfterSuspended(false);\n    this.steppers = new Map();\n    vm.onResumingExecution = () => {\n      // Let the steppers continue\n      const steppers = this.steppers.values();\n      for (let s of steppers) {\n        s.resumeFromSuspension();\n      }\n    }\n  }\n\n  onSrcChange = () => {};\n  onFinished = () => {};\n\n  get compiledCode(): Code {\n    return this.vm.code;\n  }\n\n  // Move to first instruction\n  start() {\n    // Nothing to do? Vm should be initialized?\n    this.notifyChanges();\n  }\n\n  stop() {\n    this.vm.stopRunning();\n  }\n\n  getCurrentSourceLocation(): [string?,  number?] {\n    const fileName = this.vm.getCurrentSrcFileName();\n    const lineNr = this.vm.getCurrentSrcLineNr();\n    return [fileName, lineNr];\n  }\n\n  getCurrentSrcMapEntry(): SourceMapEntry | null {\n    return this._srcMap().findEntry(this.vm.ip);\n  }\n\n  // True if the current location can be stepped into \n  // (because it contains at least one call)\n  canStepIn(): boolean {\n    const entry = this.getCurrentSrcMapEntry();\n    if (entry !== null) {\n      return entry.isCall;\n    } else {\n      return false;\n    }\n  }\n\n  canStepOut(): boolean {\n    return this.vm.savedFrames.count() > 0;\n  }\n\n  newStepOverStepper(): StepOverStepper {\n    const stepper = new StepOverStepper(this.nextStepperId, this, this.vm);\n    this.steppers.set(this.nextStepperId, stepper);\n    this.nextStepperId++;\n    return stepper;\n  }\n\n  newStepIntoStepper(): StepIntoStepper {\n    const stepper = new StepIntoStepper(this.nextStepperId, this, this.vm);\n    this.steppers.set(this.nextStepperId, stepper);\n    this.nextStepperId++;\n    return stepper;\n  }\n\n  newStepOutStepper(): StepOutStepper {\n    const stepper = new StepOutStepper(this.nextStepperId, this, this.vm);\n    this.steppers.set(this.nextStepperId, stepper);\n    this.nextStepperId++;\n    return stepper;\n  }\n\n  removeStepper(id: number) {\n    this.steppers.delete(id);\n  }\n\n  stepOver() {\n    const stepper = this.newStepOverStepper();\n    stepper.scheduleNext();\n  }\n\n  stepInto() {\n    const stepper = this.newStepIntoStepper();\n    stepper.scheduleNext();\n  }\n\n  stepOut() {\n    const stepper = this.newStepOutStepper();\n    stepper.scheduleNext();\n  }\n\n  stepUntilSrcMapEntryFound() {\n    let currentEntry = this.getCurrentSrcMapEntry();\n    while (currentEntry === null && this.vm.isRunning()) {\n      this.vm.runOneCycle();\n      currentEntry = this.getCurrentSrcMapEntry();\n    }\n  }\n\n  notifyChanges() {\n    this.highlightSource();\n    this.notifyFinished();\n  }\n\n  highlightSource() {\n    const sme = this.getCurrentSrcMapEntry()\n    if (sme !== null) {\n      this.onSrcChange();\n    }\n  }\n\n  notifyFinished() {\n    if (this.vm.isFinished()) {\n      this.onFinished();\n    }\n  }\n\n  _srcMap() {\n    return this.vm.code.srcMap;\n  }\n\n  _srcMapEntry(): SourceMapEntry | null {\n    return this._srcMap().findEntry(this.vm.ip);\n  }\n\n}", "import { hashCode, equals } from \"../vm/runtime\";\n\nexport type MapEntry = {\n  key: any,\n  value: any\n};\n\nexport class HashMap {\n\n  private _size: number = 0;\n  private buckets: Map<any, Array<MapEntry>>;\n\n  constructor() {\n    this.buckets = new Map<any, Array<MapEntry>>();\n  }\n\n  size(): number {\n    return this._size;\n  }\n\n  set(key: any, value: any) {    \n    if (value === undefined) {\n      this.delete(key);\n      return;\n    }\n\n    // Locate bucket\n    const _hashCode = hashCode(key);\n    let bucket = this.buckets.get(_hashCode);\n    if (!bucket) {\n      bucket = new Array<MapEntry>();\n      this.buckets.set(_hashCode, bucket);\n    }\n\n    let entryFound = false;\n    // Look for existing entry in bucket\n    for (let i = 0; i < bucket.length; i++) {\n      // Map already contains something under given key.\n      // Overwrite with new value.\n      if (equals(bucket[i].key, key)) {\n          bucket[i].value = value;\n          entryFound = true;\n          break;\n      }\n    }\n    // If no existing entry, add new\n    if (!entryFound) {\n      bucket.push({ key: key, value: value });\n      this._size += 1;\n    }\n\n  }\n\n  get(key: any): any | undefined {\n    const _hashCode = hashCode(key);\n    const bucket = this.buckets.get(_hashCode);\n    if (!bucket) {\n        return undefined;\n    }\n    for (let i = 0; i < bucket.length; ++i) {\n      if (equals(bucket[i].key, key)) {\n        return bucket[i].value;\n      }\n    }\n    return undefined;\n  }\n\n  has(key: any): any {\n    const _hashCode = hashCode(key);\n    const bucket = this.buckets.get(_hashCode);\n    if (!bucket) {\n        return false;\n    }\n    for (let i = 0; i < bucket.length; ++i) {\n      if (equals(bucket[i].key, key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  delete(key: any) {\n    const _hashCode = hashCode(key);\n    const bucket = this.buckets.get(_hashCode);\n    if (!bucket) {\n        return;\n    }\n    let bucketIdx = -1;\n    for (let i = 0; i < bucket.length; ++i) {\n      if (equals(bucket[i].key, key)) {\n        bucketIdx = i;\n        break;\n      }\n    }\n    if (bucketIdx >= 0) {\n      bucket.splice(bucketIdx, 1);\n      this._size -= 1;\n    }\n    if (bucket.length == 0) {\n      this.buckets.delete(_hashCode);\n    }\n  }\n\n  keys(): Array<any> {\n    const keys = new Array();\n    for (let bucket of this.buckets.values()) {\n      for (let i = 0; i < bucket.length; ++i) {\n        keys.push(bucket[i].key);\n      }\n    }\n    return keys;\n  }\n\n  values(): Array<any> {\n    const values = new Array();\n    for (let bucket of this.buckets.values()) {\n      for (let i = 0; i < bucket.length; ++i) {\n        values.push(bucket[i].value);\n      }\n    }\n    return values;\n  }\n\n  // TODO: implement returning an iterator to avoid\n  // unnecessary traversing\n    entries(): Array<MapEntry> {\n    const entries = new Array<MapEntry>();\n    for (let bucket of this.buckets.values()) {\n      for (let i = 0; i < bucket.length; ++i) {\n        entries.push(bucket[i]);\n      }\n    }\n    return entries;\n  }\n\n  toMap(depth:number = 16): Map<any,any> {\n    if (depth < 0) {\n      return new Map();\n    }\n    const result = new Map<any,any>();\n    for (let bucket of this.buckets.values()) {\n      for (let i = 0; i < bucket.length; ++i) {\n        const entry = bucket[i];\n        let key = entry.key;\n        let value = entry.value;\n        if (key instanceof HashMap) {\n          key = key.toMap(depth - 1);\n        }\n        if (value instanceof HashMap) {\n          value = value.toMap(depth - 1);\n        }\n        result.set(key, value);\n      }\n    }\n    return result;\n  }\n\n}", "// \"Alea\" random number generator\nexport function newRandomGenerator(seed: number|string|undefined = undefined) {\n  if(seed === undefined) {\n    seed = +new Date() + Math.random();\n  }\n  function Mash() {\n      let n = 4022871197;\n      return function(r: string) {\n          for(let t, s, u = 0, e = 0.02519603282416938; u < r.length; u++) {\n            s = r.charCodeAt(u);\n            let f = (e * (n += s) - (n*e|0));\n            n = 4294967296 * ((t = f * (e*n|0)) - (t|0)) + (t|0);\n          }\n          return (n|0) * 2.3283064365386963e-10;\n      }\n  }\n  return function() {\n      let m = Mash();\n      let a = m(\" \");\n      let b = m(\" \");\n      let c = m(\" \");\n      let x = 1;\n      const seedStr = seed.toString();\n      a -= m(seedStr);\n      b -= m(seedStr);\n      c -= m(seedStr);\n      a < 0 && a++;\n      b < 0 && b++;\n      c < 0 && c++;\n      return function() {\n          var y = x * 2.3283064365386963e-10 + a * 2091639; a = b, b = c;\n          return c = y - (x = y|0);\n      };\n  }();\n}", "export class Stack<T> {\n\n  lastValueUndefined: boolean;\n  elements: T[];\n\n  constructor() {\n    this.elements = [];\n    this.lastValueUndefined = false;\n  }\n\n  clear() {\n    this.elements = [];\n  }\n\n  push(element: T) {\n    if (element === undefined) {\n      // This happens when a function returns no value.\n      // Store null. It should be popped in the next cycle.\n      this.elements.push(null as T);\n      this.lastValueUndefined = true;\n    } else {\n      this.elements.push(element)\n      this.lastValueUndefined = false;\n    }\n  }\n\n  pop(): T {\n    let result = this.elements.pop();\n    if (result === undefined) {\n      throw new Error(\"Stack is empty\")\n    } else {\n      return result;\n    }\n  }\n\n  // Pop N values. Return them in original order (as they were pushed).\n  popN(count: number): any[] {\n    const result = [];\n    for (let i = 0; i < count; i++) {\n      result.unshift(this.pop());\n    }\n    return result;\n  }\n\n  // Return top-most value without removing it\n  peek(): T {\n    if (this.elements.length == 0) {\n      throw new Error(\"Stack is empty\")\n    } else {\n      // Return last element\n      return this.elements[this.elements.length - 1];\n    }\n  }\n\n  count(): number {\n    return this.elements.length;\n  }\n\n}", "import { MSMap } from \"./msmap\";\nimport { Processor } from \"./processor\";\nimport { RuntimeError } from \"./runtime\";\n\nexport class Context {\n\n  private readonly locals: MSMap;\n  private readonly parent: Context | null;\n  private readonly vm: Processor;\n\n  constructor(vm: Processor, parent: Context | null = null) {\n    this.locals = new MSMap(vm);\n    this.parent = parent;\n    this.vm = vm;\n  }\n\n  setLocal(identifier: string, value: any) {\n    if (identifier === \"globals\") {\n      throw new RuntimeError(`Can't assign to globals`);\n    } else if (identifier === \"locals\") {\n      throw new RuntimeError(`Can't assign to locals`);\n    }\n    this.locals.set(identifier, value);\n  }\n\n  getOpt(identifier: string): any | undefined {\n    if (this.locals.has(identifier)) {\n      const localValue = this.locals.get(identifier);\n      return localValue;\n    } else if (identifier === \"globals\") {\n      return this.vm.globalContext.locals;\n    } else if (identifier === \"locals\") {\n      return this.locals;\n    } else if (identifier === \"outer\") {\n      return this.getOuterLocals();\n    } else if (this.parent) {\n      return this.parent.getOpt(identifier);\n    } else {\n      return this.vm.resolveIntrinsic(identifier);\n    }\n  }\n\n  // Normally the parent context inside a function.\n  // At the global scope outer == globals.\n  private getOuterLocals(): MSMap {\n    let outerContext;\n    if (this.parent) {\n      outerContext = this.parent;\n    } else {\n      outerContext = this.vm.globalContext;\n    }\n    return outerContext.locals;\n  }\n\n}\n", "import { MSMap, MSMapFactory } from \"./msmap\";\n\nexport class ForLoop {\n  public readonly startAddr: number;\n  public readonly endAddr: number;\n  public readonly localVarName: string;\n  public readonly values: any;\n  public readonly mapObj: MSMap | null;\n  private valueIdx: number;\n  private valueCount: number;\n\n  constructor(private mapFactory: MSMapFactory, startAddr: number, endAddr: number, localVarName: string, values: any) {\n    this.startAddr = startAddr;\n    this.endAddr = endAddr;\n    this.localVarName = localVarName;\n    this.valueIdx = 0;\n    if (values instanceof Array) {\n      this.values = values;\n      this.mapObj = null;\n    } else if (values instanceof MSMap) {\n      this.values = Array.from(values.keys());\n      this.mapObj = values;\n    } else if (typeof values === \"string\") {\n      this.values = Array.from(values);\n      this.mapObj = null;\n    } else {\n      this.values = [];\n      this.mapObj = null;\n    }\n    this.valueCount = this.values.length;\n  }\n\n  isOver(): boolean {\n    return this.valueIdx >= this.valueCount;\n  }\n\n  // Gets current value and increases counter\n  iterate(): any {\n    let currentValue: any;\n    if (this.mapObj) {\n      const currentKey = this.values[this.valueIdx];\n      const currentMapValue = this.mapObj.getOpt(currentKey);\n      currentValue = this.mapFactory.newMap();\n      currentValue.set(\"key\", currentKey);\n      currentValue.set(\"value\", currentMapValue);\n    } else {\n      currentValue = this.values[this.valueIdx];\n    }\n    this.valueIdx++;\n    return currentValue;\n  }\n\n}\n\n// Used to store currently-running for-loops in the current\n// context.\nexport class ForLoopContext {\n\n  private readonly forLoops: {[id: number]: ForLoop};\n\n  constructor() {\n    this.forLoops = {};\n  }\n\n  registerForLoop(forLoopNr: number, forLoop: ForLoop) {\n    this.forLoops[forLoopNr] = forLoop;\n  }\n\n  getForLoop(forLoopNr: number): ForLoop {\n    return this.forLoops[forLoopNr];\n  }\n  \n  deleteForLoop(forLoopNr: number) {\n    delete this.forLoops[forLoopNr];\n  }\n\n}", "import { Code } from \"./code\";\nimport { Context } from \"./context\";\nimport { ForLoopContext } from \"./forloop\";\n\nexport class Frame {\n  public readonly ip: number;\n  public readonly code: Code;\n  public readonly context: Context;\n  public readonly forLoopContext: ForLoopContext;\n\n  constructor(code: Code, ip: number, frameContext: Context, forLoopContext: ForLoopContext) {\n    this.code = code;\n    this.ip = ip;\n    this.context = frameContext;\n    this.forLoopContext = forLoopContext;\n  }\n}", "import { Stack } from \"../lib/stack\";\nimport { Code } from \"./code\";\nimport { ForLoopContext } from \"./forloop\";\nimport { Frame } from \"./frame\";\nimport { Processor } from \"./processor\";\n\nexport class ProcessorState {\n\n  ip: number;\n  opStack: Stack<any>;\n  code: Code;\n  forLoopContext: ForLoopContext;\n  savedFrames: Stack<Frame>;\n  cycleCount: number;\n  onResumingExecution: () => void;\n  onFinished: () => void;\n  suspended: boolean;\n\n  constructor(vm: Processor) {\n    this.code = vm.code;\n    this.ip = vm.ip;\n    this.suspended = vm.suspended;\n    this.forLoopContext = vm.forLoopContext;\n    this.savedFrames = vm.savedFrames;\n    this.opStack = vm.opStack;\n    this.cycleCount = vm.cycleCount;\n    this.onResumingExecution = vm.onResumingExecution;\n    this.onFinished = vm.onFinished;\n  }\n\n  static resetState(vm: Processor) {\n    vm.ip = 0;\n    vm.suspended = false;\n    vm.forLoopContext = new ForLoopContext();\n    vm.savedFrames = new Stack();\n    vm.opStack = new Stack();\n    vm.cycleCount = 0;\n    vm.onResumingExecution = () => {};\n    vm.onFinished = () => {};  \n  }\n\n  restoreState(vm: Processor) {\n    vm.code = this.code;\n    vm.ip = this.ip;\n    vm.suspended = this.suspended;\n    vm.forLoopContext = this.forLoopContext;\n    vm.savedFrames = this.savedFrames;\n    vm.opStack = this.opStack;\n    vm.cycleCount = this.cycleCount;\n    vm.onResumingExecution = this.onResumingExecution;\n    vm.onFinished = this.onFinished;   \n  }\n\n}", "\nexport function parseSignature(functionSignature: string): [string, string[], any[]] {\n  let fnName: string = functionSignature;\n  let argNames: string[] = [];\n  let defaultValues: any[] = [];\n\n  // If the signature is not of a function without parameters\n  // parse the parameters and possible default values.\n  if (functionSignature.indexOf(\"(\") > 0) {\n    const nameArgsParts = functionSignature.split(\"(\");\n    fnName = nameArgsParts[0].trim();\n    const argsParts = nameArgsParts[1].slice(0,-1).split(\",\");\n    for (let part of argsParts) {\n      const argValueParts = part.split(\"=\");\n      const argName = argValueParts[0].trim();\n      let defaultValue: any = undefined;\n      if (argValueParts.length > 1) {\n        const defaultValueStr = argValueParts[1].trim();\n        // Now parse ... \n        if (defaultValueStr === \"null\") {\n          defaultValue = null;\n        } else if (defaultValueStr.startsWith(\"\\\"\")) {\n          defaultValue = defaultValueStr.slice(1,-1);\n        } else if (defaultValueStr.includes(\".\")) {\n          defaultValue = parseFloat(defaultValueStr);\n        } else {\n          defaultValue = parseInt(defaultValueStr);\n        }\n      }\n      argNames.push(argName);\n      defaultValues.push(defaultValue);\n    }\n  }\n\n  return [fnName, argNames, defaultValues];\n}", "import { newRandomGenerator } from \"../lib/random\";\nimport { Stack } from \"../lib/stack\";\nimport { TokenType } from \"../parser/tokenTypes\";\nimport { BC, hasCallPotential } from \"./bytecodes\";\nimport { Code } from \"./code\";\nimport { Context } from \"./context\";\nimport { ForLoop, ForLoopContext } from \"./forloop\";\nimport { Frame } from \"./frame\";\nimport { FuncDefArg, FuncDef, BoundFunction } from \"./funcdef\";\nimport { MSMap, MSMapFactory } from \"./msmap\";\nimport { ProcessorState } from \"./processorState\";\nimport { RuntimeError, computeAccessIndex, computeMathAssignValue, slice, chainedComparison, equals, isaEquals, greaterEquals, greaterThan, lessEquals, lessThan, toBooleanNr, add, subtract, multiply, divide, power, modulus, logic_and, logic_or } from \"./runtime\";\nimport { parseSignature } from \"./signatureParser\";\n\nexport type TxtCallback = (txt: string) => any;\n\nexport const MAX_ISA_RECURSION_DEPTH = 16;\n\nexport enum RunMode {\n  STANDARD_MODE,\n  DEBUG_MODE,\n  COOP_MODE,\n}\n\nexport class Processor implements MSMapFactory {\n\n  // Special value to indicate that a call should be aborted.\n  // Intrinsics may return this.\n  static abortCallValue: Object = {};\n\n  // The instruction pointer. Points to the position in code.\n  ip: number;\n  // The operation stack. Used for calculations and passing values.\n  opStack: Stack<any>;\n  // The code to execute.\n  code: Code;\n  // The current context.\n  context: Context;\n  // The current for-loop context.\n  forLoopContext: ForLoopContext;\n  // The global context.\n  globalContext: Context;\n  // Intrinsics stored here\n  intrinsicsMap: Map<string, BoundFunction>;\n  // Core-types\n  listCoreType: MSMap;\n  mapCoreType: MSMap;\n  stringCoreType: MSMap;\n  numberCoreType: MSMap;\n  funcRefCoreType: MSMap;\n  // Stack of frames (waiting to be returned to; not the current one).\n  savedFrames: Stack<Frame>;\n  // Counter used to return control back to host.\n  cycleCount: number;\n  // Max count of cycles per \"burst\"\n  maxCount: number = 73681;\n  // Callback when execution resumes after being suspended\n  onResumingExecution: () => void;\n  // Callback when processing done\n  onFinished: () => void;\n  // Random number generator\n  rndGenerator: Function;\n  // Timestamp when a script starts executing. Used in `time`.\n  executionStartTime: number;\n  // Flag to know when execution is suspended (e.g. waiting on a promise)\n  suspended: boolean = false;\n  // Flag to know when execution is completely halted (e.g. due to error or `exit`)\n  halted: boolean = false;\n  // Maximum depth of call stack\n  maxCallStackDepth: number = 2000;\n  // If true, continue running after being suspended.\n  // Otherwise do not run. This is the case when running in a \n  // debugging session or cooperatively.\n  runAfterSuspended: boolean;\n  // Last pop/discard value\n  // Useful when evaluating code.\n  lastValue: any;\n\n  constructor(public stdoutCallback: TxtCallback, public stderrCallback: TxtCallback) {\n    this.runAfterSuspended = true;\n    this.code = new Code();\n    this.ip = 0;\n    this.globalContext = new Context(this);\n    this.intrinsicsMap = new Map();\n    this.listCoreType = new MSMap(this);\n    this.mapCoreType = new MSMap(this);\n    this.stringCoreType = new MSMap(this);\n    this.numberCoreType = new MSMap(this);\n    this.funcRefCoreType = new MSMap(this);\n    this.context = this.globalContext;\n    this.forLoopContext = new ForLoopContext();\n    this.savedFrames = new Stack<Frame>();\n    this.opStack = new Stack();\n    this.cycleCount = 0;\n    this.onResumingExecution = () => {};\n    this.onFinished = () => {};\n    this.rndGenerator = newRandomGenerator();\n    this.executionStartTime = 0;\n    this.lastValue = undefined;\n  }\n\n  prepareForRunning(code: Code, context: Context | null = null, globalContext: Context | null = null) {\n    this.code = code;\n    this.ip = 0;\n    this.cycleCount = 0;\n\n    if (globalContext !== null) {\n      this.globalContext = globalContext;\n    }\n\n    if (context === null) {\n      this.context = this.globalContext;\n    } else {\n      this.context = context;\n    }\n\n    this.savedFrames = new Stack<Frame>();\n    this.opStack = new Stack();\n    this.suspended = false;\n    this.halted = false;\n    this.lastValue = undefined;\n  }\n\n  setRunAfterSuspended(flag: boolean) {\n    this.runAfterSuspended = flag;\n  }\n\n  getLastValue(): any {\n    return this.lastValue;\n  }\n\n  run() {\n    this.executionStartTime = performance.now();\n    this.runUntilDone();\n  }\n\n  addIntrinsic(signature: string, impl: Function) {\n    const [fnName, argNames, defaultValues] = parseSignature(signature);\n    const intrinsicFn = this.makeIntrinsicFn(impl, argNames, defaultValues);\n    this.intrinsicsMap.set(fnName, intrinsicFn);\n  }\n\n  addMapIntrinsic(target: MSMap, signature: string, impl: Function) {\n    const [fnName, argNames, defaultValues] = parseSignature(signature);\n    const intrinsicFn = this.makeIntrinsicFn(impl, argNames, defaultValues);\n    target.set(fnName, intrinsicFn);\n  }\n\n  attachExistingIntrinsic(target: MSMap, name: string, boundFunc: BoundFunction) {\n    target.set(name, boundFunc);\n  }\n\n  makeIntrinsicFn(impl: Function, argNames: string[] = [], defaultValues: any[] = []): BoundFunction {\n    const args = [];\n    const argCount = impl.length;\n\n    if (argNames.length !== argCount || argNames.length !== defaultValues.length) {\n      throw new Error(\"Length mismatch in argument count! Check function signature.\");\n    }\n\n    for (let argIdx = 0; argIdx < argCount; argIdx++) {\n      const argName = argNames[argIdx];\n      const defaultValue = defaultValues[argIdx];\n      const arg = new FuncDefArg(argName, defaultValue);\n      args.push(arg);\n    }\n    const funcDef = new FuncDef(args, impl);\n    const boundFunc = new BoundFunction(funcDef, this.globalContext);\n    return boundFunc;\n  }\n\n  newMap(): MSMap {\n    return new MSMap(this);\n  }\n\n  initRandomGenerator(seed: number | string) {\n    this.rndGenerator = newRandomGenerator(seed);\n  }\n\n  random() {\n    return this.rndGenerator();\n  }\n\n  runUntilDone() {\n    this.runSomeCycles();\n    // If not waiting on a Promise or finished\n    // running, schedule the next execution burst.\n    if (this.isRunning()) {\n      setTimeout(() => {\n        this.runUntilDone()\n      }, 0);\n    }\n  }\n\n  runSomeCycles() {\n    if (this.isRunning()) {\n      try {\n        this.executeCycles();\n      } catch(e: any) {\n        this.reportError(e);\n        this.stopRunning();\n        return;\n      }\n    }\n\n    if (this.isFinished()) {\n      // Call after program ends normally\n      this.cleanupAfterRunning();\n    }\n  }\n\n  runOneCycle() {\n    this.executeCycles(1);\n  }\n\n  private reportError(e: any) {\n    if (e instanceof RuntimeError) {\n      e.setSourceLocation(this.getCurrentSrcFileName(), this.getCurrentSrcLineNr());\n      const fileName = this.getCurrentSrcFileName();\n      e.setSourceLocation(fileName, this.getCurrentSrcLineNr());\n    }\n    if (e[\"message\"]) {\n      this.stderrCallback(e.message);\n    }\n    console.error(e);\n  }\n\n  private executeCycles(maxCount: number | null = null) {\n    maxCount = maxCount !== null ? maxCount : this.maxCount;\n    this.cycleCount = 0;\n    while(this.cycleCount < maxCount) {\n      // Finish if IP > len(opcodes)\n      if (this.ip >= this.code.opCodes.length) {\n        break\n      }\n      // Process OpCode\n      switch (this.code.opCodes[this.ip]) {\n        case BC.CALL: {\n          const funcName: string = this.code.arg1[this.ip] as string;\n          const paramCount: number = this.code.arg2[this.ip] as number;\n          // Pop params\n          const params = this.opStack.popN(paramCount);\n\n          const optValue: any | undefined = this.context.getOpt(funcName);\n          if (optValue === undefined) {\n            throw new RuntimeError(`Could not resolve \"${funcName}\"`);\n          }\n          const resolvedFunc: any = optValue;\n          this.performCall(resolvedFunc, params);\n          break;\n        }\n        case BC.FUNCREF_CALL: {\n          const paramCount: number = this.code.arg1[this.ip] as number;\n          // Pop params\n          const params = this.opStack.popN(paramCount);\n          // Pop call target\n          const maybeFuncRef: any = this.opStack.pop();\n          this.performCall(maybeFuncRef, params);\n          break;\n        }\n        case BC.PROPERTY_CALL: {\n          const paramCount: number = this.code.arg1[this.ip] as number;\n          // Pop params\n          const params = this.opStack.popN(paramCount);\n          // Pop property name\n          const methodName = this.opStack.pop();\n          // Pop call target\n          const callTarget = this.opStack.pop();\n\n          let srcMap: MSMap | null = null;\n          let resolvedMethod: any;\n          if (callTarget instanceof MSMap) {\n            [resolvedMethod, srcMap] = callTarget.getWithSource(methodName);\n          } else {\n            // Lookup in base type\n            const baseTypeMap = this.selectCoreTypeMap(callTarget);\n            resolvedMethod = baseTypeMap.get(methodName);\n          }\n          this.performCall(resolvedMethod, params, callTarget, srcMap);\n          break;\n        }\n        case BC.RETURN: {\n          // Pop frame if we are inside of a function call.\n          if (this.savedFrames.count() > 0) {\n            this.popFrame();\n          } else {\n            // Otherwise pop return value\n            this.opStack.pop();\n            // and treat it as a no-op.\n            this.ip += 1;\n          }\n          break;\n        }\n        case BC.ASSIGN_LOCAL: {\n          const varName: string = this.code.arg1[this.ip] as string;\n          const valueToAssign = this.opStack.pop();\n          this.context.setLocal(varName, valueToAssign)\n          this.ip += 1;\n          break;\n        }\n        case BC.ASSIGN_INDEXED: {\n          // pop target\n          const assignTarget = this.opStack.pop();\n          // pop value\n          const valueToAssign = this.opStack.pop();\n          // pop index\n          let index = this.opStack.pop();\n\n          const isString = typeof assignTarget === \"string\";\n          const isList = assignTarget instanceof Array;\n          const isMap = assignTarget instanceof MSMap;\n\n          if (isList) {\n            const effectiveIndex = computeAccessIndex(assignTarget, index);\n            assignTarget[effectiveIndex] = valueToAssign;\n          } else if(isMap) {\n            assignTarget.set(index, valueToAssign);\n          } else if(isString) {\n            throw new RuntimeError(\"Cannot assign to String (immutable)\");\n          } else {\n            throw new RuntimeError(\"Cannot set to element of this type\");\n          }\n\n          this.ip += 1;\n          break;\n        }\n        case BC.DOT_ASSIGN : {\n          const propertyName: string = this.code.arg1[this.ip];\n          const assignTarget = this.opStack.pop();\n          const valueToAssign = this.opStack.pop();\n\n          if (!(assignTarget instanceof MSMap)) {\n            throw new RuntimeError(`Assignment target must be a Map`);\n          }\n\n          assignTarget.set(propertyName, valueToAssign);\n          this.ip += 1;\n          break;         \n        }\n        case BC.MATH_ASSIGN_LOCAL: {\n          const varName: string = this.code.arg1[this.ip] as string;\n          const opTokenType: TokenType = this.code.arg2[this.ip] as TokenType;\n          const operand = this.opStack.pop();\n          // Get existing value\n          const existingValue = this.context.getOpt(varName);\n          if (existingValue !== undefined) {\n            const finalValue = computeMathAssignValue(this, existingValue, opTokenType, operand);\n            this.context.setLocal(varName, finalValue);\n          } else {\n            throw new RuntimeError(`Undefined Local Identifier: '${varName}' is unknown in this context`);\n          }\n          this.ip += 1;\n          break;\n        }\n        case BC.MATH_ASSIGN_INDEXED: {\n          const opTokenType: TokenType = this.code.arg1[this.ip] as TokenType;\n          // pop value\n          const operand = this.opStack.pop();\n          // pop index\n          let index = this.opStack.pop();\n          // pop target\n          const assignTarget = this.opStack.pop();\n\n          const isString = typeof assignTarget === \"string\";\n          const isList = assignTarget instanceof Array;\n          const isMap = assignTarget instanceof MSMap;\n\n          if (isList) {\n            const effectiveIndex = computeAccessIndex(assignTarget, index);\n            const currentValue = assignTarget[effectiveIndex];\n            const finalValue = computeMathAssignValue(this, currentValue, opTokenType, operand);\n            assignTarget[effectiveIndex] = finalValue;\n          } else if(isMap) {\n            const currentValue = assignTarget.get(index);\n            const finalValue = computeMathAssignValue(this, currentValue, opTokenType, operand);\n            assignTarget.set(index, finalValue);\n          } else if(isString) {\n            throw new RuntimeError(\"Cannot assign to String (immutable)\");\n          } else {\n            throw new RuntimeError(\"Cannot set to element of this type\");\n          }\n\n          this.ip += 1;\n          break;\n        }\n        case BC.MATH_DOT_ASSIGN : {\n          const propertyName: string = this.code.arg1[this.ip];\n          const opTokenType: TokenType = this.code.arg2[this.ip] as TokenType;\n          const operand = this.opStack.pop();\n          const assignTarget = this.opStack.pop();\n\n          if (!(assignTarget instanceof MSMap)) {\n            throw new RuntimeError(`Assignment target must be a Map`);\n          }\n\n          const currentValue = assignTarget.get(propertyName);\n          const finalValue = computeMathAssignValue(this, currentValue, opTokenType, operand);\n          assignTarget.set(propertyName, finalValue);\n\n          this.ip += 1;\n          break;         \n        }\n\n        case BC.EVAL_ID: {\n          const identifier = this.code.arg1[this.ip];\n          const isFuncRef: boolean = this.code.arg2[this.ip];\n          const optValue = this.context.getOpt(identifier);\n          if (optValue !== undefined) {\n            this.callOrPushValue(optValue, isFuncRef);\n          } else {\n            throw new RuntimeError(`Undefined Identifier: '${identifier}' is unknown in this context`);\n          }\n          break;\n        }\n        case BC.INDEXED_ACCESS: {\n          const isFuncRef: boolean = this.code.arg1[this.ip];\n          let index = this.opStack.pop();\n          const accessTarget = this.opStack.pop();\n\n          const isString = typeof accessTarget === \"string\";\n          const isList = accessTarget instanceof Array;\n          const isMap = accessTarget instanceof MSMap;\n\n          let value: any;\n          let srcMap: MSMap | null = null;\n\n          if (isList || isString) {\n            if (typeof index === \"number\") {\n              const effectiveIndex = computeAccessIndex(accessTarget, index);\n              value = accessTarget[effectiveIndex];\n            } else if (isList) {\n              [value, srcMap] = this.listCoreType.getWithSource(index);\n            } else if (isString) {\n              [value, srcMap] = this.stringCoreType.getWithSource(index);\n            } else {\n              throw new Error(\"Uncovered case\");\n            }\n          } else if(isMap) {\n            [value, srcMap] = accessTarget.getWithSource(index);\n          } else if (typeof index === \"number\") {\n            throw new RuntimeError(`Null Reference Exception: can't index into null`);\n          } else {\n            throw new RuntimeError(`Type Error (while attempting to look up ${index})`);\n          }\n\n          this.callOrPushValue(value, isFuncRef, accessTarget, srcMap);\n          break;\n        }\n        case BC.DOT_ACCESS : {\n          const propertyName: string = this.code.arg1[this.ip];\n          const isFuncRef: boolean = this.code.arg2[this.ip];\n          const accessTarget = this.opStack.pop();\n\n          let value: any;\n          let srcMap: MSMap;\n          if (accessTarget instanceof MSMap) {\n            [value, srcMap] = accessTarget.getWithSource(propertyName);\n          } else if (accessTarget === null) {\n            throw new RuntimeError(`Type Error (while attempting to look up ${propertyName})`);\n          } else {\n            // Lookup in base type - redefine access-target\n            srcMap = this.selectCoreTypeMap(accessTarget);\n            value = srcMap.get(propertyName);\n          }\n          this.callOrPushValue(value, isFuncRef, accessTarget, srcMap);\n          break;         \n        }\n        case BC.SUPER_DOT_ACCESS : {\n          const propertyName: string = this.code.arg1[this.ip];\n          const isFuncRef: boolean = this.code.arg2[this.ip];\n          const superMap = this.context.getOpt(\"super\");\n          const selfMap = this.context.getOpt(\"self\");\n\n          if (superMap === undefined) {\n            throw new RuntimeError(`Undefined Identifier: 'super' is unknown in this context`);\n          }\n          if (selfMap === undefined) {\n            throw new RuntimeError(`Undefined Identifier: 'self' is unknown in this context`);\n          }\n\n          let value: any;\n          let srcMap: MSMap |null = null;\n          if (superMap instanceof MSMap) {\n            // Use the \"superMap\" only to lookup the value\n            // But later call it with the \"selfMap\"\n            [value, srcMap] = superMap.getWithSource(propertyName);\n            if (value === undefined) {\n              throw new RuntimeError(`Type Error (while attempting to look up ${propertyName})`);\n            }\n          } else if (superMap === null) {\n            throw new RuntimeError(`Type Error (while attempting to look up ${propertyName})`);\n          }\n\n          // Note that the source-map and the super-map might not be\n          // the same. Pass the source-map to compute a new \"super\".\n          this.callOrPushValue(value, isFuncRef, selfMap, srcMap);\n          break;         \n        }\n        case BC.SUPER_DOT_CALL: {\n          const paramCount: number  = this.code.arg1[this.ip];\n\n          const superMap = this.context.getOpt(\"super\");\n          const selfMap = this.context.getOpt(\"self\");\n\n          if (superMap === undefined) {\n            throw new RuntimeError(`Undefined Identifier: 'super' is unknown in this context`);\n          }\n          if (selfMap === undefined) {\n            throw new RuntimeError(`Undefined Identifier: 'self' is unknown in this context`);\n          }\n\n          // Pop params\n          const params = this.opStack.popN(paramCount);\n          // Pop property name\n          const methodName = this.opStack.pop();\n\n          let resolvedMethod: any;\n          let srcMap: MSMap |null = null;\n          if (superMap instanceof MSMap) {\n            // Use the \"superMap\" only to lookup the value\n            // But later call it with the \"selfMap\"\n            [resolvedMethod, srcMap] = superMap.getWithSource(methodName);\n            if (resolvedMethod === undefined) {\n              throw new RuntimeError(`Type Error (while attempting to look up ${methodName})`);\n            }\n          } else if (superMap === null) {\n            throw new RuntimeError(`Type Error (while attempting to look up ${methodName})`);\n          }\n\n          this.performCall(resolvedMethod, params, selfMap, srcMap);\n          break;\n        }\n        case BC.SLICE_SEQUENCE: {\n          // Pop parameters\n          const endIdx = this.opStack.pop();\n          const startIdx = this.opStack.pop();\n          const sliceTarget = this.opStack.pop();\n          const newCollection = slice(this, sliceTarget, startIdx, endIdx);\n          // Push result\n          this.opStack.push(newCollection);\n          this.ip += 1;\n          break;\n        }\n        case BC.CHAINED_COMPARISON: {\n          const pairCount: number = this.code.arg1[this.ip];\n          // Pop operators\n          const operators: string[] = this.opStack.popN(pairCount);\n          // Pop values\n          const values: any[] = this.opStack.popN(pairCount + 1);\n          // Calculate result\n          const result = chainedComparison(values, operators);\n          // Push result\n          this.opStack.push(result);\n          this.ip += 1;\n          break;\n        }\n        case BC.PUSH: {\n          const value: any = this.code.arg1[this.ip];\n          // If it's a FuncDef, store as bound-function with the current context\n          if (value instanceof FuncDef) {\n            const boundFunction = new BoundFunction(value, this.context);\n            this.opStack.push(boundFunction);\n          } else {\n            this.opStack.push(value);\n          }\n          this.ip += 1;\n          break;\n        }\n        case BC.BUILD_LIST: {\n          const elementCount: any = this.code.arg1[this.ip];\n          const elements: any[] = this.opStack.popN(elementCount);\n          this.opStack.push(elements);\n          this.ip += 1;\n          break;\n        }\n        case BC.BUILD_MAP: {\n          const elementCount: any = this.code.arg1[this.ip];\n          const elements: any[] = this.opStack.popN(elementCount * 2);\n          const newMap = new MSMap(this);\n          // Iterate over elements and process key/value\n          // Advance by 2, processing in pairs\n          for (let i = 0; i < elements.length; i += 2) {\n            const mapKey = elements[i];\n            const mapValue = elements[i+1];\n            newMap.set(mapKey, mapValue);\n          }\n          this.opStack.push(newMap);\n          this.ip += 1;\n          break;\n        }\n        case BC.NEW_MAP: {\n          const parentMap = this.opStack.pop();\n          if (!(parentMap instanceof MSMap)) {\n            throw new RuntimeError(`Operator \"new\" can only be used with Maps`);\n          }\n          const newMap = parentMap.newChildMap();\n          this.opStack.push(newMap);                \n          this.ip += 1;\n          break;\n        }\n        case BC.COMPARE_EQ: {\n          const valueB = this.opStack.pop()\n          const valueA = this.opStack.pop()\n          const result = equals(valueA, valueB)\n          this.opStack.push(result)\n          this.ip += 1\n          break;\n        }\n        case BC.COMPARE_NE: {\n          const valueB = this.opStack.pop();\n          const valueA = this.opStack.pop();\n          if (!equals(valueA, valueB)) {\n            this.opStack.push(1)\n          } else {\n            this.opStack.push(0)\n          }\n          this.ip += 1\n          break;\n        }\n        case BC.COMPARE_ISA: {\n          const valueB = this.opStack.pop()\n          const valueA = this.opStack.pop()\n          const result = isaEquals(this, valueA, valueB)\n          this.opStack.push(result)\n          this.ip += 1\n          break;\n        }\n        case BC.COMPARE_GE: {\n          const valueB = this.opStack.pop()\n          const valueA = this.opStack.pop()\n          const result = greaterEquals(valueA, valueB)\n          this.opStack.push(result)\n          this.ip += 1\n          break;\n        }\n        case BC.COMPARE_GT: {\n          const valueB = this.opStack.pop()\n          const valueA = this.opStack.pop()\n          const result = greaterThan(valueA, valueB)\n          this.opStack.push(result)\n          this.ip += 1\n          break;\n        }\n        case BC.COMPARE_LE: {\n          const valueB = this.opStack.pop()\n          const valueA = this.opStack.pop()\n          const result = lessEquals(valueA, valueB)\n          this.opStack.push(result)\n          this.ip += 1\n          break;\n        }\n        case BC.COMPARE_LT: {\n          const valueB = this.opStack.pop()\n          const valueA = this.opStack.pop()\n          const result = lessThan(valueA, valueB)\n          this.opStack.push(result)\n          this.ip += 1\n          break;\n        }\n        case BC.POP_JUMP_FALSE: {\n          const jumpAddr = this.code.arg1[this.ip]\n          let value = this.opStack.pop();\n          value = toBooleanNr(value);\n          if (value == 0) {\n            this.ip = jumpAddr\n          } else {\n            this.ip += 1\n          }\n          break;\n        }\n        case BC.JUMP_IF_TRUE: {\n          const jumpAddr = this.code.arg1[this.ip];\n          // Leave value on the stack\n          let value = this.opStack.peek();\n          value = toBooleanNr(value);\n          if (value == 1) {\n            this.ip = jumpAddr\n          } else {\n            this.ip += 1\n          }\n          break;\n        }\n        case BC.JUMP_IF_FALSE: {\n          const jumpAddr = this.code.arg1[this.ip];\n          // Leave value on the stack\n          let value = this.opStack.peek();\n          value = toBooleanNr(value);\n          if (value == 0) {\n            this.ip = jumpAddr\n          } else {\n            this.ip += 1\n          }\n          break;\n        }\n        case BC.ADD_VALUES: {\n          const valueInStack_2 = this.opStack.pop()\n          const valueInStack_1 = this.opStack.pop()\n          const result = add(this, valueInStack_1, valueInStack_2)\n          this.opStack.push(result)\n          this.ip += 1;\n          break;\n        }\n        case BC.SUBTRACT_VALUES: {\n          const valueInStack_2 = this.opStack.pop()\n          const valueInStack_1 = this.opStack.pop()\n          const result = subtract(valueInStack_1, valueInStack_2)\n          this.opStack.push(result)\n          this.ip += 1;\n          break;\n        }\n        case BC.MULTIPLY_VALUES: {\n          const valueInStack_2 = this.opStack.pop()\n          const valueInStack_1 = this.opStack.pop()\n          const result = multiply(valueInStack_1, valueInStack_2)\n          this.opStack.push(result)\n          this.ip += 1;\n          break;\n        }\n        case BC.DIVIDE_VALUES: {\n          const valueInStack_2 = this.opStack.pop()\n          const valueInStack_1 = this.opStack.pop()\n          const result = divide(valueInStack_1, valueInStack_2)\n          this.opStack.push(result)\n          this.ip += 1;\n          break;\n        }\n        case BC.POWER_VALUES: {\n          const valueInStack_2 = this.opStack.pop()\n          const valueInStack_1 = this.opStack.pop()\n          const result = power(valueInStack_1, valueInStack_2)\n          this.opStack.push(result)\n          this.ip += 1;\n          break;\n        }\n        case BC.MOD_VALUES: {\n          const valueInStack_2 = this.opStack.pop()\n          const valueInStack_1 = this.opStack.pop()\n          const result = modulus(valueInStack_1, valueInStack_2)\n          this.opStack.push(result)\n          this.ip += 1;\n          break;\n        }\n        case BC.LOGIC_AND_VALUES: {\n          const valueInStack_2 = this.opStack.pop()\n          const valueInStack_1 = this.opStack.pop()\n          const result = logic_and(valueInStack_1, valueInStack_2)\n          this.opStack.push(result)\n          this.ip += 1;\n          break;\n        }\n        case BC.LOGIC_OR_VALUES: {\n          const valueInStack_2 = this.opStack.pop()\n          const valueInStack_1 = this.opStack.pop()\n          const result = logic_or(valueInStack_1, valueInStack_2)\n          this.opStack.push(result)\n          this.ip += 1;\n          break;\n        }\n        case BC.SUBTR_N: {\n          const valueToSubtract = this.code.arg1[this.ip];\n          const valueInStack = this.opStack.pop()\n          const result = subtract(valueInStack, valueToSubtract)\n          this.opStack.push(result)\n          this.ip += 1;\n          break;\n        }\n        case BC.DIVIDE_N: {\n          const dividend = this.code.arg1[this.ip];\n          const valueInStack = this.opStack.pop()\n          const result = divide(valueInStack, dividend)\n          this.opStack.push(result)\n          this.ip += 1;\n          break;\n        }\n        case BC.NEGATE_BOOLEAN: {\n          const valueInStack = this.opStack.pop();\n          const booleanNr = toBooleanNr(valueInStack);\n          const result = booleanNr == 0 ? 1 : 0;\n          this.opStack.push(result);\n          this.ip += 1;\n          break;\n        }\n        case BC.NEGATE_NUMBER: {\n          const valueInStack = this.opStack.pop();\n          if (typeof valueInStack !== \"number\") {\n            throw new RuntimeError(`Value must be a number`);\n          } else {\n            const result = -1 * valueInStack;\n            this.opStack.push(result);\n            this.ip += 1;\n            break;\n          }\n        }\n        case BC.JUMP: {\n          this.ip = this.code.arg1[this.ip]\n          break;\n        }\n        case BC.POP: {\n          // Pop and discard value\n          if (this.opStack.lastValueUndefined) {\n            this.opStack.pop();\n            this.lastValue = undefined;\n          } else {\n            this.lastValue = this.opStack.pop();\n          }\n          this.ip += 1;\n          break;\n        }\n        case BC.CREATE_FOR_LOOP: {\n          const forLoopNr = this.code.arg1[this.ip];\n          // Retrieve for-loop parameters\n          const startAddr = this.opStack.pop();\n          const endAddr = this.opStack.pop();\n          const values = this.opStack.pop();\n          const localVarName = this.opStack.pop();\n          // Create for-loop in current context\n          const forLoop = new ForLoop(this, startAddr, endAddr, localVarName, values);\n          this.forLoopContext.registerForLoop(forLoopNr, forLoop);\n          // Advance IP\n          this.ip += 1;\n          break;\n        }\n        case BC.ITERATE_FOR_LOOP: {\n          const forLoopNr = this.code.arg1[this.ip];\n          const forLoop = this.forLoopContext.getForLoop(forLoopNr);\n          if (forLoop.isOver()) {\n            this.ip = forLoop.endAddr;\n            this.forLoopContext.deleteForLoop(forLoopNr);\n          } else {\n            const value = forLoop.iterate();\n            // Assign to local variable\n            this.context.setLocal(forLoop.localVarName, value);\n            this.ip += 1;\n          }\n          break;\n        }\n        case BC.BREAK_FOR_LOOP: {\n          const forLoopNr = this.code.arg1[this.ip];\n          const forLoop = this.forLoopContext.getForLoop(forLoopNr);\n          this.forLoopContext.deleteForLoop(forLoopNr);\n          this.ip = forLoop.endAddr;\n          break;\n        }\n        case BC.CONTINUE_FOR_LOOP: {\n          const forLoopNr = this.code.arg1[this.ip];\n          const forLoop = this.forLoopContext.getForLoop(forLoopNr);\n          this.ip = forLoop.startAddr;\n          break;\n        }\n        case BC.PRINT_TOP: {\n          const value = this.opStack.pop()\n          console.log(\"Value: \" + value)\n          this.ip += 1;\n          break;\n        }\n        default: {\n          console.log(\"ip:\", this.ip);\n          console.error(\"Bytecode not supported: \", this.code.opCodes[this.ip]);\n          throw new RuntimeError(\"Bytecode not supported: \" + this.code.opCodes[this.ip]);\n        }\n      } // switch\n      this.cycleCount++;\n    } // while\n  } // executeCycles\n\n  isRunning(): boolean {\n    return !this.isFinished() && !this.isSuspended();\n  }\n\n  isFinished(): boolean {\n    return this.ip >= this.code.opCodes.length;\n  }\n\n  isSuspended(): boolean {\n    return this.suspended;\n  }\n\n  stopRunning() {\n    this.forceFinish();\n    this.cleanupAfterRunning();\n  }\n\n  private forceFinish() {\n    this.opStack.clear();\n    this.cycleCount = this.maxCount;\n    this.ip = this.code.opCodes.length;\n    this.halted = true;\n  }\n\n  private cleanupAfterRunning() {\n    // Check that stack is balanced (empty)\n    if (this.opStack.count() > 0 && !this.halted) {\n      console.info(\"Stack: \", this.opStack);\n      throw new RuntimeError(\"Stack was not empty!\")\n    }\n    // Invoke callback\n    this.onFinished();\n  }\n\n  runAtCurrentPosition(code: Code): Promise<void> {\n    \n    // Build promise which will be resolved when code\n    // is done running.\n    const promise = new Promise<void>((resolve) => {\n      // Save current state\n      const previousState = new ProcessorState(this);\n      const currentContext = this.context;\n      const currentGlobalContext = this.globalContext;\n      // Reset current state\n      ProcessorState.resetState(this);\n      // Set running code at the current context\n      this.prepareForRunning(code, currentContext, currentGlobalContext);\n      // Setup onFinished callback\n      this.onFinished = () => {\n        if (!this.halted) {\n          // Restore previous state if VM not halted\n          previousState.restoreState(this);\n        } else {\n          // At least restore the \"onFinished\" which we modified\n          this.onFinished = previousState.onFinished;\n        }\n        // Resolve promise\n        resolve();\n      };\n      // Start executing\n      this.runUntilDone();\n    });\n\n    return promise;\n  }\n\n  yieldExecution() {\n    this.cycleCount = this.maxCount;\n    this.suspended = false;\n  }\n\n  private suspendExecution() {\n    this.cycleCount = this.maxCount;\n    this.suspended = true;\n  }\n\n  private resumeExecution() {\n    if (!this.suspended) {\n      return;\n    }\n    this.suspended = false;\n    // Only continue running if specified\n    if (this.runAfterSuspended) {\n      this.runUntilDone();\n    }\n    // Invoke callback\n    this.onResumingExecution();\n  }\n\n  couldResultInCall(): boolean {\n    const op = this.code.opCodes[this.ip];\n    const result = hasCallPotential(op);\n    return result;\n  }\n\n  pushFrame() {\n    const frame = new Frame(this.code, this.ip, this.context, this.forLoopContext);\n    this.savedFrames.push(frame);\n    // Remove at some point?\n    if (this.savedFrames.count() > this.maxCallStackDepth) {\n      throw new RuntimeError(\"Call stack too deep\");\n    }\n  }\n\n  popFrame() {\n    const frame = this.savedFrames.pop();\n    this.ip = frame.ip;\n    this.context = frame.context;\n    this.forLoopContext = frame.forLoopContext;\n    this.code = frame.code;\n  }\n\n  getCurrentSrcLineNr(): number | undefined {\n    const optSrcMapEntry = this.code.srcMap.findEntry(this.ip);\n    if (optSrcMapEntry !== null) {\n      return optSrcMapEntry.srcLoc.start.row;\n    } else {\n      return undefined;\n    }\n  }\n\n  getCurrentSrcFileName(): string | undefined {\n    const srcFile = this.code.srcMap.srcFile;\n    return srcFile;\n  }\n\n  private selectCoreTypeMap(accessTarget: any): MSMap {\n    if (accessTarget instanceof Array) {\n      return this.listCoreType;\n    } else if (typeof accessTarget === \"string\") {\n      return this.stringCoreType;\n    } else if (accessTarget instanceof MSMap) {\n      return this.mapCoreType;\n    } else if (typeof accessTarget === \"number\") {\n      return this.numberCoreType;\n    } else {\n      throw new RuntimeError(`No core-type map for value ${accessTarget}`);\n    }\n  }\n\n  resolveIntrinsic(identifier: string): BoundFunction|undefined {\n    const optIntrinsicFn = this.intrinsicsMap.get(identifier);\n    return optIntrinsicFn;\n  }\n\n  private callOrPushValue(value: any, isFuncRef: boolean, accessSrc: any | undefined = undefined, srcMap: MSMap | null = null) {\n    // If it's a function and we are not dealing with a function\n    // reference, the function should be called.\n    // The resulting value will be put in the stack instead.\n    if (value instanceof BoundFunction && !isFuncRef) {\n      this.performCall(value, [], accessSrc, srcMap);\n    } else {\n      // Otherwise use the value as-is\n      this.opStack.push(value)\n      this.ip += 1;\n    }\n  }\n\n  private performCall(maybeFunction: any, paramValues: any[], dotCallTarget: any | undefined = undefined, srcMap: MSMap | null = null) {\n    \n    const paramCount = paramValues.length;\n\n    if (!(maybeFunction instanceof BoundFunction)) {\n      if (paramCount > 0) {\n        throw new RuntimeError(`Too Many Arguments`);\n      } else {\n        throw new RuntimeError(`Attempting to call a non-function`);\n      }\n    }\n\n    const boundFunc = maybeFunction as BoundFunction;\n    const funcDef = boundFunc.funcDef;\n\n    let funcArgCount = funcDef.argNames.length;\n\n    let isNativeSelfFunction = (\n      funcDef.isNative() \n      && dotCallTarget !== undefined\n      && funcDef.argNames.length > 0\n      && funcDef.argNames[0] === \"self\"\n    );\n\n    // Subtract one argument for instrinsic self-functions\n    if (isNativeSelfFunction) {\n      funcArgCount -= 1;\n    }\n\n    // If parameters missing, complete with default values\n    if (paramCount > funcArgCount) {\n      throw new RuntimeError(`Too many parameters calling function.`)\n    } else if (paramCount < funcArgCount) {\n      // Push the missing default argument values\n      const missingArgCount = funcArgCount - paramCount;\n      const defaultValues = funcDef.getLastNEffectiveDefaultValues(missingArgCount);\n      for (let value of defaultValues) {\n        paramValues.push(value);\n      }\n    }\n\n    if (funcDef.isNative()) {\n      const func = funcDef.getFunction();\n      // Add dot-call target \"manually\", if self-function\n      if (isNativeSelfFunction) {\n        // The \"self\" parameter\n        paramValues.unshift(dotCallTarget);\n      }\n      // Call with parameters\n      const retVal = func.apply(this, paramValues);\n\n      // Abort this call and return immediately\n      if (retVal === Processor.abortCallValue) {\n        return;\n      }\n\n      // Check if returned value is a Promise\n      if (retVal instanceof Promise) {\n        this.suspendUntilPromiseResolved(retVal);\n      } else {\n        // Return value is normal object\n        // Push return value to stack\n        this.opStack.push(retVal);\n        // Advance IP\n        this.ip += 1;\n      }\n    } else {\n      // Function is a MiniScript-code function.\n      // (not an intrinsic)\n\n      // Let it return to the next bytecode after the call\n      this.ip += 1;\n      this.pushFrame();\n\n      // Setup next frame\n      this.code = funcDef.getCode();\n      this.context = new Context(this, boundFunc.context);\n      this.forLoopContext = new ForLoopContext();\n      this.ip = 0;\n\n      // Pop and set parameters as variables\n      let argNames = funcDef.argNames;\n    \n      if (dotCallTarget !== undefined) {\n        argNames = argNames.filter((n:string) => n !== \"self\");\n      }\n\n      for (let i = 0; i < argNames.length; i++) {\n        const argName = argNames[i];\n        const paramValue = paramValues[i];\n        this.context.setLocal(argName, paramValue);\n      }\n      // Add dot-call target if any\n      if (dotCallTarget !== undefined) {\n        // The \"self\" value\n        this.context.setLocal(\"self\", dotCallTarget);\n        // The \"super\" value\n        if(srcMap !== null) {\n          // The \"source map\" is where the bound-function was found.\n          // Any calls to \"super\" refer to the isa-map above this one.\n          if (srcMap.hasParent()) {\n            const isaMap = srcMap.parentMap();\n            this.context.setLocal(\"super\", isaMap);\n          }\n        }\n      }\n    }    \n  }\n\n  private suspendUntilPromiseResolved(promise: Promise<any>) {\n    // Mark VM for suspension\n    this.suspendExecution();\n    \n    // Deal with promise resolved value\n    promise.then((retVal: any) => {   \n      // Push return value to stack\n      this.opStack.push(retVal);\n      // Advance IP\n      this.ip += 1;\n      // Resume execution\n      this.resumeExecution();\n    });\n  }\n\n}", "import { HashMap, MapEntry } from \"../lib/hashmap\";\nimport { MAX_ISA_RECURSION_DEPTH, Processor } from \"./processor\";\nimport { RuntimeError } from \"./runtime\";\n\nexport type MSMapFactory = {\n  newMap(): MSMap;\n}\n\nexport class MSMap {\n\n  private mapObj: HashMap;\n  private valueSetOverrides: null | Map<any, Function>;\n\n  constructor(private vm: Processor) {\n    this.mapObj = new HashMap();\n    this.valueSetOverrides = null;\n  }\n\n  get(key: any): any {\n    const result = this.getOpt(key);\n    if (result === undefined) {\n      throw new RuntimeError(`Key Not Found: '${key}' not found in map`);\n    } else {\n      return result;\n    }\n  }\n\n  getOpt(key: any, depth: number = 0): any | undefined {\n    if (depth > MAX_ISA_RECURSION_DEPTH) {\n      throw new RuntimeError(`__isa depth exceeded (perhaps a reference loop?)`);\n    }\n    if (this.mapObj.has(key)) {\n      return this.mapObj.get(key);\n    } else if (this.hasParent()) {\n      return this.parentMap().getOpt(key, depth + 1); \n    } else if (this === this.vm.mapCoreType) {\n      return undefined;\n    } else {\n      return this.vm.mapCoreType.getOpt(key, depth + 1); \n    }\n  }\n\n  getWithSource(key: any, depth: number = 0): [any, MSMap] {\n    if (depth > MAX_ISA_RECURSION_DEPTH) {\n      throw new RuntimeError(`__isa depth exceeded (perhaps a reference loop?)`);\n    }\n    if (this.mapObj.has(key)) {\n      return [this.mapObj.get(key), this];\n    } else if (this.hasParent()) {\n      return this.parentMap().getWithSource(key, depth + 1); \n    } else if (this === this.vm.mapCoreType) {\n      throw new RuntimeError(`Key Not Found: '${key}' not found in map`);\n    } else {\n      return this.vm.mapCoreType.getWithSource(key, depth + 1); \n    }\n  }\n\n  size(): number {\n    return this.mapObj.size();\n  }\n\n  // Creates a sub-map / instance, having this\n  // as its isa-parent.\n  newChildMap(): MSMap {\n    const newMap = new MSMap(this.vm);\n    newMap.set(\"__isa\", this);\n    return newMap;\n  }\n\n  hasParent() {\n    return this.mapObj.has(\"__isa\")  \n  }\n\n  parentMap(): MSMap {\n    const result = this.mapObj.get(\"__isa\");\n    if (result instanceof MSMap) {\n      return result\n    } else {\n      throw new RuntimeError(\"No parent map. Always check first with hasParent()\");\n    }\n  }\n\n  // Makes it possible to execute an action before attempting\n  // to set a new value and even change the value to be set.\n  overrideSettingValue(key: any, callback: (newValue: any) => any) {\n    if (this.valueSetOverrides === null) {\n      this.valueSetOverrides = new Map();\n    }\n    this.valueSetOverrides.set(key, callback);\n  }\n\n  removeSettingValueOverride(key: any) {\n    if (this.valueSetOverrides instanceof Map) {\n      this.valueSetOverrides.delete(key);\n    }\n  }\n\n  set(key: any, value: any) {\n    // Process value-set overrider\n    // Keep returned value\n    if (this.valueSetOverrides !== null) {\n      const overrideFunction = this.valueSetOverrides.get(key);\n      if (overrideFunction instanceof Function) {\n        value = overrideFunction(value);\n      }\n    }\n\n    // Set passed / overridden value\n    this.mapObj.set(key, value);\n  }\n\n  has(key: any): any {\n    return this.mapObj.has(key);\n  }\n\n  delete(key: any) {\n    this.mapObj.delete(key);\n  }\n\n  keys(): Array<any> {\n    return this.mapObj.keys();\n  }\n\n  values(): Array<any> {\n    return this.mapObj.values();\n  }\n\n  entries(): Array<MapEntry> {\n    return this.mapObj.entries();\n  }\n\n  isaEquals(type: MSMap): number {\n    if (type === this.vm.mapCoreType) {\n      return 1;\n    } else {\n      // Walk up the \"isa\" chain until a match is found\n      let p = null;\n\t\t\tp = this.getOpt(\"__isa\");\n\t\t\twhile (p != null) {\n\t\t\t\tif (p === type) {\n          return 1;\n        }\n\t\t\t\tif (!(p instanceof MSMap)) {\n          return 0;\n        } else {\n          p = p.getOpt(\"__isa\");\n        }\n\t\t\t}\n\t\t\treturn 0;\n    }\n  }\n\n  toJSMap(depth:number = 16): Map<any,any> {\n    return this.mapObj.toMap(depth);\n  }\n\n}", "import { TokenType } from \"../parser/tokenTypes\";\nimport { BoundFunction } from \"./funcdef\";\nimport { MSMap, MSMapFactory } from \"./msmap\";\nimport { Processor } from \"./processor\";\n\nexport class RuntimeError extends Error {\n  \n  constructor(private baseMsg: string) {\n    super(`Runtime Error: ${baseMsg}`);\n  }\n\n  setSourceLocation(fileName?: string, lineNr?: number) {\n    let location: string;\n    if (fileName !== undefined && lineNr !== undefined) {\n      location = ` [${fileName} line ${lineNr}]`;\n    } else if (lineNr !== undefined) { \n      location = ` [line ${lineNr}]`;\n    } else {\n      location = \"\";\n    }\n    \n    const msg = `Runtime Error: ${this.baseMsg}${location}`;\n    this.message = msg;\n  }\n  \n}\n\ntype IndexedCollection = {\n  length: number;\n}\n\ntype Concatenable = {\n  concat(a: any): any;\n}\n\nexport function notEquals(a: any, b: any): number {\n  return equals(a, b) == 1 ? 0 : 1; \n}\n\nexport function equals(a: any, b: any, recursionDepth: number = 16): number {\n  if (recursionDepth < 0) {\n    return 1;\n  }\n  // JavaScript does not compare Arrays the way we want\n  // so we have to implement our own version.\n  if (a instanceof Array && b instanceof Array) {\n    if (a.length !== b.length) {\n      return 0;\n    } else {\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] === b[i]) {\n          continue;\n        }\n        if (equals(a[i], b[i], recursionDepth - 1) === 0) {\n          return 0;\n        }\n      }\n      return 1;\n    }\n  } else if (a instanceof MSMap && b instanceof MSMap) {\n    if (a.size() !== b.size()) {\n      return 0;\n    } else {\n      for (let aKey of a.keys()) {\n        if (!b.has(aKey)) {\n          return 0;\n        }\n        const aValue = a.get(aKey);\n        const bValue = b.get(aKey);\n        if (equals(aValue, bValue, recursionDepth - 1)) {\n          continue;\n        } else if (equals(aValue, bValue, recursionDepth - 1) !== 1) {\n          return 0;\n        }\n      }\n      return 1;\n    }\n  } else {\n    return a === b ? 1 : 0;\n  }\n}\n\nexport function isaEquals(vm: Processor, value: any, type: any): number {\n  if (value === null) {\n    return type === null ? 1 : 0;\n  } else if (type === null) {\n    return 0;\n  } else if (typeof value === \"number\") {\n    return type === vm.numberCoreType ? 1 : 0;\n  } else if (typeof value === \"string\") {\n    return type === vm.stringCoreType ? 1 : 0;\n  } else if (value instanceof Array) {\n    return type === vm.listCoreType ? 1 : 0;\n  } else if (value instanceof MSMap) {\n    return value.isaEquals(type);\n  } else if (value instanceof BoundFunction) {\n    return type === vm.funcRefCoreType ? 1 : 0;\n  } else {\n    return 0;\n  }\n}\n\nexport function greaterEquals(a: any, b: any): number | null {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a >= b ? 1 : 0;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a >= b ? 1 : 0;\n  } else {\n    return null;\n  }\n}\n\nexport function greaterThan(a: any, b: any): number | null {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a > b ? 1 : 0;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a > b ? 1 : 0;\n  } else {\n    return null;\n  }\n}\n\nexport function lessEquals(a: any, b: any): number | null {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a <= b ? 1 : 0;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a <= b ? 1 : 0;\n  } else {\n    return null;\n  }\n}\n\nexport function lessThan(a: any, b: any): number | null {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a < b ? 1 : 0;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a < b ? 1 : 0;\n  } else {\n    return null;\n  }\n}\n\nexport function chainedComparison(values: any[], operators: string[]): number {\n  const pairCount = operators.length;\n  // Evaluate in pairs\n  for (let i = 0; i < pairCount; i++) {\n    const operator = operators[i];\n    const left = values[i];\n    const right = values[i+1];\n    let result: number | null;\n    if (operator === \"==\") {\n      result = equals(left, right);\n    } else if (operator === \"!=\") {\n      result = notEquals(left, right);\n    } else if (operator === \">\") {\n      result = greaterThan(left, right);\n    } else if (operator === \">=\") {\n      result = greaterEquals(left, right);\n    } else if (operator === \"<\") {\n      result = lessThan(left, right);\n    } else if (operator === \"<=\") {\n      result = lessEquals(left, right);\n    } else {\n      throw new RuntimeError(\"Invalid operator\");\n    }\n    if (!result) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nexport function add(mapFactory: MSMapFactory, a: any, b: any): any {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    // Perform arithmetic addition\n    return a + b\n  } else if (typeof a === \"string\" || typeof b === \"string\") {\n    // Convert both values to String and concatenate\n    return toStr(a) + toStr(b);\n  } else if (a instanceof Array) {\n    if (b instanceof Array) {\n      return a.concat(b);\n    } else {\n      throw new RuntimeError(`Got ${b} instead of another List`);\n    }\n  } else if (a instanceof MSMap) {\n    if (b instanceof MSMap) {\n      const combined = mapFactory.newMap();\n      for (let e of a.entries()) {\n        combined.set(e.key,e.value);\n      }\n      for (let e of b.entries()) {\n        combined.set(e.key,e.value);\n      }\n      return combined;\n    } else {\n      throw new RuntimeError(`Got ${toStr(b)} where a Map was required`);\n    }\n  } else if (a === null) {\n    return null;\n  } else if (typeof a === \"number\" && b === null) {\n    return a;\n  } else {\n    console.info(\"Not supported for values\",\"a:\",a,\"b:\",b);\n    throw new RuntimeError(`Cannot add ${formatValue(a,true)} + ${formatValue(b,true)}`);\n  }\n}\n\nexport function subtract(a: any, b: any): any {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a - b;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    const suffixIdx = a.lastIndexOf(b);\n    // Force match at the end\n    const matchIdx = a.length - b.length;\n    if (suffixIdx >= 0 && suffixIdx == matchIdx) {\n      return a.substring(0, suffixIdx); \n    } else {\n      return a;\n    }\n  } else if (a === null) {\n    return null;\n  } else if (typeof a === \"number\" && b === null) {\n    return a;\n  } else {\n    console.info(\"Not supported for values\",\"a:\",a,\"b:\",b);\n    throw new RuntimeError(`Cannot subtract ${formatValue(a,true)} - ${formatValue(b,true)}`);\n  }\n}\n\nexport function divide(a: any, b: any): number |null {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a / b\n  } else if (a === null) {\n    return null;\n  } else if (typeof a === \"number\" && b === null) {\n    return a / 0;\n  } else {\n    console.info(\"Not supported for values\",\"a:\",a,\"b:\",b);\n    throw new RuntimeError(`Cannot divide ${formatValue(a,true)} / ${formatValue(b,true)}`);\n  }\n}\n\nexport function multiply(a: any, b: any): any {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a * b;\n  } else if (a instanceof Array || typeof a === \"string\") {\n    if (typeof b === \"number\") {\n      let result: Concatenable = (typeof a === \"string\") ? \"\" : new Array();\n      if (b > 0) {\n        // Add whole repetitions\n        const repetitionCount = Math.floor(b);\n        for (let i = 0; i < repetitionCount; i++) {\n          result = result.concat(a);\n        }\n        // Take the part after \"comma\" with (%1) (e.g. 7.25 -> 0.25)\n        // and use it to know how many more elements of the collection\n        // to take. For this, multiply by the total length and take first\n        // N elements.\n        const additionalElementsSliceEnd = Math.floor((b % 1) * a.length);\n        const additionalElements = a.slice(0, additionalElementsSliceEnd);\n        result = result.concat(additionalElements);\n      }\n      return result;\n    } else {\n      throw new RuntimeError(`Number required for replication. Got ${b} instead.`);\n    }\n  } else if (a === null) {\n    return null;\n  } else if (typeof a === \"number\" && b === null) {\n    return 0;\n  } else {\n    console.error(\"Not supported for values\",\"a:\",a,\"b:\",b);\n    throw new RuntimeError(`Cannot multiply ${formatValue(a,true)} * ${formatValue(b,true)}`);\n  }\n}\n\nexport function power(a: any, b: any): number | null {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return Math.pow(a, b);\n  } else if (a === null) {\n    return null;\n  } else if (typeof a === \"number\" && b === null) {\n    return 1;\n  } else {\n    console.info(\"Not supported for values\",\"a:\",a,\"b:\",b);\n    throw new RuntimeError(`Cannot raise to the power ${formatValue(a,true)} ^ ${formatValue(b,true)}`);\n  }\n}\n\nexport function modulus(a: any, b: any): number | null {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a % b;\n  } else if (a === null) {\n    return null;\n  } else if (typeof a === \"number\" && b === null) {\n    return a % 0;\n  } else {\n    console.info(\"Not supported for values\",\"a:\",a,\"b:\",b);\n    throw new RuntimeError(`Cannot perform modulus ${formatValue(a,true)} % ${formatValue(b,true)}`);\n  }\n}\n\nexport function logic_and(a: any, b: any): number {\n  a = toBooleanNr(a);\n  b = toBooleanNr(b);\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return absClamp01(a * b);\n  } else {\n    console.info(\"Not supported for values\",\"a:\",a,\"b:\",b);\n    throw new RuntimeError(`Cannot perform ${formatValue(a,true)} && ${formatValue(b,true)}`);\n  }\n}\n\nexport function logic_or(a: any, b: any): number {\n  a = toBooleanNr(a);\n  b = toBooleanNr(b);\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return absClamp01(a + b - a * b);\n  } else {\n    console.info(\"Not supported for values\",\"a:\",a,\"b:\",b);\n    throw new RuntimeError(`Cannot perform ${formatValue(a,true)} || ${formatValue(b,true)}`);\n  }\n}\n\nexport function absClamp01(value: number): number {\n  if (value < 0) value = -value;\n  if (value > 1) return 1;\n  return value;\n}\n\nexport function slice(vm: Processor, sliceTarget: any, startIdx: number, endIdx: number): any {\n  // Check list-target\n  if (!(sliceTarget instanceof Array || typeof sliceTarget === \"string\")) {\n    throw new RuntimeError(`Slice target must be List or String [line ${vm.getCurrentSrcLineNr()}]`);\n  }\n  // Check / compute indexes\n  if (startIdx !== null) {\n    checkInt(startIdx, `Slice-start should be an integer value [line ${vm.getCurrentSrcLineNr()}]`);\n    startIdx = computeSliceIndex(sliceTarget, startIdx);\n  } else {\n    // Take slice from the beginning\n    startIdx = 0;\n  }\n  if (endIdx !== null) {\n    checkInt(endIdx, `Slice-end should be an integer value [line ${vm.getCurrentSrcLineNr()}]`);\n    endIdx = computeSliceIndex(sliceTarget, endIdx);\n  } else {\n    // Take slice to the end\n    endIdx = sliceTarget.length;\n  }\n  // Compute slice\n  const newCollection = sliceTarget.slice(startIdx, endIdx);\n  return newCollection;\n}\n\n// Here it's important that the index is valid and within the access-target\nexport function computeAccessIndex(accessTarget: IndexedCollection, index: number): number {\n  const intIdx = toIntegerValue(index);\n  // Compute effective index\n  const effectiveIndex = (intIdx < 0) ? intIdx + accessTarget.length : intIdx;\n  // Check bounds\n  if (effectiveIndex < 0 || effectiveIndex >= accessTarget.length) {\n    throw new RuntimeError(`Index Error (list index ${index} out of range)`);\n  }\n  return effectiveIndex;\n}\n\n// Here we can be flexible, adjust values and allow index to be == collection.length\nexport function computeSliceIndex(accessTarget: IndexedCollection, index: number): number {\n  // Compute effective index\n  const effectiveIndex = (index < 0) ? index + accessTarget.length : index;\n  // Adjust values\n  if (effectiveIndex < 0) {\n    return 0;\n  } else if (effectiveIndex >= accessTarget.length) {\n    return accessTarget.length;\n  }\n  // Otherwise return as calculated\n  return effectiveIndex;\n}\n\nexport function computeMathAssignValue(mapFactory: MSMapFactory, currentValue: any, opTokenType: TokenType, operand: any): any {\n  switch(opTokenType) {\n    case TokenType.PLUS_ASSIGN:\n      return add(mapFactory, currentValue, operand);\n    case TokenType.MINUS_ASSIGN:\n      return subtract(currentValue, operand);\n    case TokenType.DIV_ASSIGN:\n      return divide(currentValue, operand);\n    case TokenType.MULT_ASSIGN:\n      return multiply(currentValue, operand);\n    case TokenType.MOD_ASSIGN:\n      return modulus(currentValue, operand);\n    case TokenType.POW_ASSIGN:\n      return power(currentValue, operand);\n    default:\n      throw new RuntimeError(\"Invalid token-type: \" + TokenType[opTokenType]);\n  }\n}\n\nexport function toBooleanNr(value: any): number {\n  if (value === null) {\n    return 0;\n  } else if (typeof value == \"number\" ) {\n    return value;\n  } else if (value instanceof Array) {\n    return value.length;\n  } else if (typeof value === \"string\") {\n    return value.length > 0 ? 1 : 0;\n  } else if (value instanceof MSMap) {\n    return value.size() > 0 ? 1 : 0;\n  } else {\n    throw new RuntimeError(\"Type not supported: \" + value);\n  }\n}\n\nexport function toStr(a: any): string {\n  if (typeof a === \"number\") {\n    return \"\" + a;\n  } else if (typeof a === \"string\") {\n    return a;\n  } else {\n    return formatValue(a);\n  }\n}\n\n// Not the same as trying to convert to number (e.g. `val(\"3\")`)\nexport function toNumberValue(value: any): number {\n  if (typeof value === \"number\" ) {\n    return value;\n  } else {\n    return 0;\n  }\n}\n\nexport function toIntegerValue(value: any): number {\n  if (typeof value == \"number\" ) {\n    return Math.trunc(value);\n  } else {\n    return 0;\n  }\n}\n\nexport function toTwoNumbers(value: any): [number, number] {\n  let a: number;\n  let b: number;\n  if (value instanceof Array) {\n    a = toNumberValue(value[0]);\n    b = toNumberValue(value[1]);\n  } else {\n    const n = toNumberValue(value);\n    a = n;\n    b = n;\n  }\n  return [a, b];\n}\n\nexport function round(n: any, decimalPlaces: any): number | undefined {\n  if (typeof n === \"number\" && typeof decimalPlaces === \"number\") {\n    if (decimalPlaces >= 0) {\n      const places = Math.pow(10, decimalPlaces);      \n      return Math.round(n * places) / places;\n    } else {\n      const pow10Nr = Math.pow(10, -decimalPlaces);\n      return Math.round(n / pow10Nr) * pow10Nr;\n    }\n  } else {\n    return undefined;\n  }\n}\n\nexport function hashCode(value: any, recursionDepth: number = 16): number {\n  if (value === null) {\n    return -1;\n  } else if (value instanceof Array) {\n    return listHashCode(value, recursionDepth - 1);\n  } else if (value instanceof MSMap) {\n    return mapHashCode(value, recursionDepth - 1);\n  } else {\n    const valueStr = toStr(value);\n    return stringHashCode(valueStr);\n  }\n}\n\nexport function listHashCode(list: Array<any>, recursionDepth: number = 16): number {\n  let result = hashCode(list.length);\n  if (recursionDepth < 1) {\n    return result;\n  }\n  for (let i = 0; i < list.length; i++) {\n    const value = list[i];\n    if (value != null) {\n      result ^= hashCode(value, recursionDepth - 1);\n    }\n  }\n  return result;\n}\n\nexport function mapHashCode(map: MSMap, recursionDepth: number = 16) {\n  let result = stringHashCode(toStr(map.size));\n  if (recursionDepth < 0) {\n    return result;\n  }\n  for (let {key, value} of map.entries()) {\n    result ^= hashCode(key, recursionDepth - 1);\n    if (value != null) {\n      result ^= hashCode(value, recursionDepth - 1);\n    }\n  }\n  return result;\n}\n\nexport function stringHashCode(str: string): number {\n  let hash = 0;\n  for (let i = 0, len = str.length; i < len; i++) {\n      let chr = str.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n\nexport function getRandomInt(vm: Processor, max: number): number { \n  return Math.floor(vm.random() * max);\n}\n\nexport function checkRange(i: number, min: number, max: number, desc: string = \"index\") {\n  if (i < min || i > max) {\n    throw new RuntimeError(`Index Error: ${desc} (${i}) out of range (${min} to ${max})`);\n  }\n}\n\nexport function checkNumber(arg: any, errorMsg: string, vm: Processor|null = null) {\n  if (Number.isFinite(arg)) {\n    return;\n  } else if (vm instanceof Processor) {\n    throw new RuntimeError(errorMsg);\n  } else {\n    throw new RuntimeError(errorMsg);\n  }\n}\n\nexport function checkInt(arg: any, errorMsg: string, vm: Processor|null = null) {\n  if (Number.isInteger(arg)) {\n    return;\n  } else if (vm instanceof Processor) {\n    throw new RuntimeError(errorMsg);\n  } else {\n    throw new RuntimeError(errorMsg);\n  }\n}\n\nexport function isNullOrEmpty(str: string): boolean {\n  if (str === null) {\n    return true;\n  } else if (typeof str === \"string\") {\n    return str === \"\";\n  } else {\n    throw new RuntimeError(\"Invalid argument: \" + str);\n  }\n}\n\n\nexport function formatValue(value: any, quoteStrings: boolean = false, depth: number = 16): string {\n  let text = \"\";\n  if (typeof value === \"number\") {\n    text = formatNumber(value);\n  } else if (value instanceof Array) {\n    if (depth < 0 ) {\n      return \"[ a List ]\";\n    }\n    const formattedValues = [];\n    for (const e of value) {\n      formattedValues.push(formatValue(e, true, depth - 12));\n    }\n    text = \"[\" + formattedValues.join(\", \") + \"]\";\n  } else if (value instanceof MSMap) {\n    if (depth < 0 ) {\n      return \"{ a Map }\";\n    }\n    const formattedPairs = [];\n    for (let e of value.entries()) {\n      const formattedKey = formatValue(e.key, true, depth - 15);\n      const formattedValue = formatValue(e.value, true, depth - 14);\n      const formattedPair = formattedKey + \": \" + formattedValue;\n      formattedPairs.push(formattedPair);\n    }\n    text = \"{\" + formattedPairs.join(\", \") + \"}\";\n  } else if (typeof(value) === \"string\" && quoteStrings) {\n    text = \"\\\"\" + value + \"\\\"\";\n  } else if (typeof(value) === \"boolean\") {\n    return value ? \"1\" : \"0\";\n  } else if (value instanceof BoundFunction) {\n    const formattedArgs: string[] = [];\n    for (let arg of value.funcDef.arguments) {\n      if (arg.defaultValue !== undefined) {\n        formattedArgs.push(`${arg.name}=${arg.defaultValue}`);\n      } else {\n        formattedArgs.push(`${arg.name}`);\n      }\n    }\n    const joinedArgs = formattedArgs.join(\", \");\n    return `FUNCTION(${joinedArgs})`;\n  } else {\n    text = \"\" + value;\n  }\n  return text;\n}\n\nfunction formatNumber(value: number): string {\n  const isFloat = !Number.isInteger(value) && Number.isFinite(value);\n  let text: string = \"\";\n  if (isFloat) {\n    if (value > 1E10 || value < -1E10 || (value < 1E-6 && value > -1E-6)) {\n      // Format very large or small numbers in exponential form\n      text = value.toExponential(6);\n      // Pad exponential with leading zero if only one digit\n      text = text.replace(/[eE]([-+])(\\d)$/,\"E$10$2\")\n    } else {\n      text = \"\" + (round(value, 6) || 0);\n    }\n  } else {\n    text = value.toString();\n  }\n  return text;\n}\n", "import { Processor } from \"../../vm/processor\";\nimport { toIntegerValue } from \"../../vm/runtime\";\n\nexport function addBitOperationIntrinsics(p: Processor) {\n\n  p.addIntrinsic(\"bitAnd(i=0,j=0)\", \n  function(i: any, j: any): number {\n    i = toIntegerValue(i);\n    j = toIntegerValue(j);\n    return i & j;\n  });\n\n  p.addIntrinsic(\"bitOr(i=0,j=0)\", \n  function(i: any, j: any): number {\n    i = toIntegerValue(i);\n    j = toIntegerValue(j);\n    return i | j;\n  });\n\n  p.addIntrinsic(\"bitXor(i=0,j=0)\", \n  function(i: any, j: any): number {\n    i = toIntegerValue(i);\n    j = toIntegerValue(j);\n    return i ^ j;\n  });\n\n}", "import { Processor } from \"../../vm/processor\";\nimport { toStr } from \"../../vm/runtime\";\n\nexport function addCharIntrinsics(p: Processor) {\n  \n  p.addIntrinsic(\"code(self)\", \n  function(x: any): number | null {\n    if (x !== null) {\n      const s = toStr(x);\n      if (x === \"\") {\n        return null\n      }\n      const result = s.charCodeAt(0);\n      return result;\n    } else {\n      return 0;\n    }\n  });\n\n  p.addIntrinsic(\"char(n)\", \n  function(x: any): string {\n    if (typeof x === \"number\" && x > 0) {\n      const s = String.fromCharCode(x)\n      return s;\n    }\n    return String.fromCharCode(0);\n  });\n\n}\n", "import { MSMap } from \"../../vm/msmap\";\nimport { Processor } from \"../../vm/processor\";\nimport { toNumberValue, checkNumber, RuntimeError, toIntegerValue, checkRange, toStr, equals, isNullOrEmpty, slice, toBooleanNr } from \"../../vm/runtime\";\n\nexport function addCollectionIntrinsics(p: Processor) {\n\n  p.addIntrinsic(\"range(start,stop,step=null)\", \n  function(start: any, stop: any, step: number) {\n    start = toNumberValue(start);\n    stop = toNumberValue(stop);\n\n    const result: number[] = [];\n\n    if (start === stop) {\n      return [start];\n    } else if (start < stop) {\n      step = step === null ? 1 : step;\n      checkNumber(step, \"Argument 'step' should be a number\", p);\n      if (step <= 0) {\n        return new Array();\n      }\n      for (let i = start; i <= stop; i += step) {\n        result.push(i);\n      }\n    } else {\n      step = step === null ? -1 : step;\n      checkNumber(step, \"Argument 'step' should be a number\", p);\n      if (step >= 0) {\n        return new Array();\n      }\n      for (let i = start; i >= stop; i += step) {\n        result.push(i);\n      }\n    }\n\n    return result;\n  });\n\n  p.addIntrinsic(\"len(self)\",\n  function(self: any): number | null {\n    if (self instanceof Array || typeof self === \"string\") {\n      return self.length;\n    } else if (self instanceof MSMap) {\n      return self.size();\n    } else {\n      return null;\n    }\n  });\n\n  p.addIntrinsic(\"sum(self)\", \n  function(self: any): number {\n    let list: any[];\n    if (self instanceof Array) {\n      list = self as Array<any>;\n    } else if (self instanceof MSMap) {\n      list = Array.from( self.values() );\n    } else {\n      return 0;\n    }\n    let total = 0;\n    for (let e of list) {\n      total += toNumberValue(e);\n    }\n    return total;\n  });\n\n  p.addIntrinsic(\"insert(self,index,value)\", \n  function(self: any, index: number, value: any): any | null {\n    if (index === null) {\n      throw new RuntimeError(\"index argument required\");\n    }\n    if (typeof index !== \"number\") {\n      throw new RuntimeError(\"number required for index argument\");\n    }\n    index = toIntegerValue(index);\n    if (index < 0) {\n      index += self.length + 1;\n    }\n    checkRange(index, 0, self.length);\n    if (self instanceof Array) {\n      self.splice(index, 0, value);\n    } else if (typeof self === \"string\") {\n      const valueStr = toStr(value);\n      const result = [self.slice(0, index), valueStr, self.slice(index)].join('');\n      return result;\n    } else {\n      throw new RuntimeError(\"insert called on an invalid type\");\n    }\n  });\n\n  p.addIntrinsic(\"remove(self,k)\", \n  function(self: any, k: any): any {\n    if (self instanceof MSMap) {\n      if (self.has(k)) {\n        self.delete(k);\n        return 1;\n      } else {\n        return 0;\n      }\n    } else if (self instanceof Array) {\n      if (k == null) {\n        throw new RuntimeError(\"argument to 'remove' must not be null\");\n      }\n      let index = toIntegerValue(k);\n      if (index < 0) {\n        index += self.length;\n      }\n      checkRange(index, 0, self.length-1);\n      self.splice(index, 1);\n      return null;\n    } else if (typeof self === \"string\") {\n      if (k == null) {\n        throw new RuntimeError(\"argument to 'remove' must not be null\");\n      }\n      const s = toStr(k);\n      const foundPos = s.indexOf(k);\n      if (foundPos < 0) {\n        return self;\n      }\n      const result = self.replace(k, \"\");\n      return result;\n    }\n    throw new RuntimeError(\"Type Error: 'remove' requires map, list, or string\");\n  });\n\n  p.addIntrinsic(\"replace(self,oldVal,newVal,maxCount=null)\",\n  function(self: any, oldVal: any, newVal: any, maxCountVal: any): any {\n    if (self === null) {\n      throw new RuntimeError(\"argument to 'replace' must not be null\");\n    }\n    let maxCount = -1;\n    if (maxCountVal !== null) {\n      maxCount = toIntegerValue(maxCountVal);\n      if (maxCount < 1) {\n        return self;\n      }\n    }\n    let count = 0;\n    if (self instanceof MSMap) {\n      const keysToChange = [];\n      for (let key of self.keys()) {\n        const value = self.get(key);\n        if (equals(value, oldVal)) {\n          keysToChange.push(key);\n          count += 1;\n          if (maxCount > 0 && count === maxCount) {\n            break;\n          }\n        }\n      }\n      for (let key of keysToChange) {\n        self.set(key, newVal);\n      }\n      return self;\n    } else if (self instanceof Array) {\n      for (let i = 0; i < self.length; i++) {\n        if (equals(self[i], oldVal)) {\n          self[i] = newVal;\n          count++;\n        }\n        if (maxCount > 0 && count == maxCount) {\n          break;\n        }\n      }\n      return self;\n    } else if (typeof self === \"string\") {\n      let str = toStr(self);\n      let oldstr = oldVal === null ? \"\" : toStr(oldVal);\n      if (isNullOrEmpty(oldstr)) {\n        throw new RuntimeError(\"replace: oldval argument is empty\");\n      }\n      let newstr = newVal == null ? \"\" : toStr(newVal);\n      let idx = 0;\n      while (true) {\n        idx = str.indexOf(oldstr, idx);\n        if (idx < 0) {\n          break;\n        }\n        str = str.substring(0, idx) + newstr + str.substring(idx + oldstr.length);\n        idx += newstr.length;\n        count++;\n        if (maxCount > 0 && count == maxCount) {\n          break;\n        }\n      }\n      return str;\n    }\n    throw new RuntimeError(\"Type Error: 'replace' requires map, list, or string\");\n  });\n\n  p.addIntrinsic(\"slice(seq,from=0,to=null)\",\n  function(sequence: any, fromIdx: any, toIdx: any,): any {\n    const newCollection = slice(p, sequence, fromIdx, toIdx);\n    return newCollection;\n  });\n\n  p.addIntrinsic(\"split(self,delimiter=\\\" \\\",maxCount=-1)\",\n  function(self: any, delimiter: any, maxCount: any,): Array<string> {\n    self = toStr(self);\n    delimiter = toStr(delimiter);\n    maxCount = toIntegerValue(maxCount);\n\n    let result: string[] = [];\n    let pos = 0;\n\n\t\twhile (pos < self.length) {\n\t\t  let nextPos;\n\t\t\t\n      if (maxCount >= 0 && result.length == maxCount - 1) {\n        // Force finishing loop\n        nextPos = self.length;\n      } else if (delimiter.length == 0) {\n        // Split by every char if delimiter is empty\n        nextPos = pos + 1;\n      } else { \n        // Advance \n        nextPos = self.indexOf(delimiter, pos);\n      }\n\t\t\t\t\t\n      if (nextPos < 0) {\n        nextPos = self.length;\n      }\n\t\t\t\t\t\n      result.push(self.substring(pos, nextPos));\n\n\t\t\tpos = nextPos + delimiter.length;\n\n\t\t\tif (pos == self.length && delimiter.length > 0) {\n        result.push(\"\");\n      }\n\t\t}\n\n\t\treturn result;\n  });\n\n  p.addIntrinsic(\"indexOf(self,value,after=null)\", \n  function(self: any, value: any, after: number | null): number | null {\n    if (self instanceof Array || typeof self === \"string\") {\n      let afterIdx = after !== null ? after : -1;\n      // If negative, wrap around\n      if (afterIdx < -1) {\n        afterIdx += self.length;\n      }\n      if (afterIdx < -1 || afterIdx >= self.length-1) {\n        return null;\n      }\n      const idx = self.indexOf(value, afterIdx + 1);\n      return idx >= 0 ? idx : null;\n    } else if (self instanceof MSMap) {\n      let startSearch = after == null ? true : false;\n      for(let key of self.keys()) {\n        if (startSearch) {\n          const mapValue = self.get(key);\n          if (mapValue === value) {\n            return key;\n          }\n        } else if (key === after) {\n          startSearch = true;\n        }\n      }\n      return null;\n    } else {\n      return null;\n    }\n  });\n\n  p.addIntrinsic(\"join(self,delimiter=\\\" \\\")\",\n  function(self: any, delimiter: any): string {\n    const delim = toStr(delimiter);\n    if (!(self instanceof Array)) {\n      return self;\n    } else {\n      const list: (string|null)[] = [];\n      for (let value of self) {\n        if (value === null) {\n          list.push(\"\");\n        } else {\n          list.push(toStr(value));\n        }\n      }\n      const result = list.join(delim);\n      return result;\n    }\n  });\n\n  p.addIntrinsic(\"hasIndex(self,index)\", \n  function(self: any, index: any): number | null {\n    if (self instanceof MSMap) {\n      return self.has(index) ? 1 : 0;\n    } else if (self instanceof Array || typeof self === \"string\") {\n      if (typeof index === \"number\" && self.length > 0) {\n        return index >= -self.length && index < self.length ? 1 : 0;\n      } else {\n        return 0;\n      }\n    } else {\n      return null;\n    }\n  });\n\n  p.addIntrinsic(\"pop(self)\", \n  function(self: any): any | null {\n    if (self instanceof Array) {\n      if (self.length < 1) {\n        return null;\n      }\n      const result = self.pop();\n      // Return the removed element\n      return result;\n    } else if (self instanceof MSMap) {\n      if (self.size() < 1) {\n        return null;\n      }\n      // Remove the element corresponding to (the arbirtrary)\n      // first key\n      const firstKey = self.keys()[0];\n      self.delete(firstKey);\n      // Return removed key\n      return firstKey;\n    } else {\n      return null;\n    }\n  });\n\n  p.addIntrinsic(\"pull(self)\", \n  function(self: any): any | null {\n    if (self instanceof Array) {\n      if (self.length < 1) {\n        return null;\n      }\n      const result = self[0];\n      // Remove the first element (in place!)\n      self.splice(0,1);\n      // Return the removed element\n      return result;\n    } else if (self instanceof MSMap) {\n      if (self.size() < 1) {\n        return null;\n      }\n      // Remove the element corresponding to (the arbirtrary)\n      // first key\n      const firstKey = self.keys()[0];\n      self.delete(firstKey);\n      // Return removed key\n      return firstKey;\n    } else {\n      return null;\n    }\n  });\n\n  p.addIntrinsic(\"push(self,value)\", \n  function(self: any, value: any): any | null {\n    if (self instanceof Array) {\n      self.push(value);\n      return self;\n    } else if (self instanceof MSMap) {\n      self.set(value, 1);\n      return self;\n    } else {\n      return null;\n    }\n  });\n\n  p.addIntrinsic(\"indexes(self)\", \n  function(self: any): any[] | null {\n    if (self instanceof MSMap) {\n      const keys = Array.from( self.keys() );\n      return keys;\n    } else if (self instanceof Array || typeof self === \"string\") {\n      const indexes: number[] = [];\n      for (let i = 0; i < self.length; i++) {\n        indexes.push(i);\n      }\n      return indexes;\n    } else {\n      return null;\n    }\n  });\n\n  p.addIntrinsic(\"values(self)\", \n  function(self: any): any {\n    if (self instanceof MSMap) {\n      const values = Array.from( self.values() );\n      return values;\n    } else if (typeof self === \"string\") {\n      const letters = Array.from( self );\n      return letters;\n    } else {\n      return self;\n    }\n  });\n\n  // Sorts IN PLACE!\n  p.addIntrinsic(\"sort(self,byKey=null,ascending=1)\", \n  function(self: any, byKey: any | null, ascending: any): any {\n    type KeyedValue = {\n      sortKey: any,\n      value: any\n    };\n    const compareSameType = (a: any, b: any): -1|0|1 => {\n      if (a < b) {\n        return -1;\n      } else if (a > b) {\n        return 1;\n      } else {\n        return 0;\n      }\n    };\n    const compareByValues = (a: any, b: any): -1|0|1 => {\n      // Put \"null\" values at the end\n      if (a === null) {\n        if (b === null) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n      if (b === null) {\n        return -1;\n      }\n      // Do string-comparison if any argument is a string\n      if (typeof a === \"string\" || typeof b === \"string\") {\n        const aStr = toStr(a);\n        const bStr = toStr(b);\n        return compareSameType(aStr, bStr);\n      }\n      // Do numeric comparison if both arguments are numbers\n      if (typeof a === \"number\" && typeof b === \"number\") {\n        return compareSameType(a, b);\n      }\n      // Otherwise consider them equal\n      return 0;\n    };\n    const compareByKeys = (a: KeyedValue, b: KeyedValue): -1|0|1 => {\n      return compareByValues(a.sortKey, b.sortKey);\n    };\n\n    if (!(self instanceof Array)) {\n      return self;\n    }\n\n    if (self.length < 2) {\n      return self;\n    }\n\n    if (byKey === null) {\n      self.sort(compareByValues);\n    } else {\n      // Sort by key\n      const intKey = toIntegerValue(byKey);\n      const keyedList: KeyedValue[] = [];\n      // Build list of keyed-values\n      for (let i = 0; i < self.length; i++) {\n        const value = self[i];\n        let sortKey: any = null;\n        if (value instanceof MSMap) {\n          sortKey = value.getOpt(byKey) || null;\n        } else if (value instanceof Array) {\n          if (intKey > -value.length && intKey < value.length) {\n            const normalizedIdx = intKey % value.length;\n            sortKey = value[normalizedIdx];\n          }\n        }\n        const keyedValue = {\n          sortKey: sortKey,\n          value: value\n        };\n        keyedList.push(keyedValue);\n      }\n      // Sort list of keyed-values (in-place)\n      keyedList.sort(compareByKeys);\n      // Extract values to build a values-only (sorted) list\n      // Empty list and push all values to it\n      self.splice(0, self.length);\n      for (let keyedValue of keyedList) {\n        self.push(keyedValue.value);\n      }\n    }\n\n    if (toBooleanNr(ascending) === 0) {\n      self.reverse();\n    }\n\n    return self;\n  });\n\n}\n", "import { Processor } from \"../../vm/processor\";\nimport { formatValue } from \"../../vm/runtime\";\n\nexport function addConversionIntrinsics(p: Processor) {\n\n  p.addIntrinsic(\"str(self)\", \n  function(value: any): string {\n    const result: string = formatValue(value);\n    return result;\n  });\n\n  // Try to convert to a number\n  p.addIntrinsic(\"val(self)\", \n  function(x: any): number | null {\n    if (typeof x === \"number\") {\n      return x;\n    } else if (typeof x === \"string\") {\n      let result: number = Number(x);\n      if (isNaN(result)) {\n        return 0;\n      } else {\n        return result;\n      }\n    } else {\n      return null;\n    }\n  });\n  \n}\n", "import { MSMap } from \"../../vm/msmap\";\nimport { Processor } from \"../../vm/processor\";\n\nexport function addCoreTypesIntrinsics(p: Processor) {\n\n  p.addIntrinsic(\"string\", \n  function(): MSMap {\n    return p.stringCoreType;\n  });\n\n  p.addIntrinsic(\"list\", \n  function(): MSMap {\n    return p.listCoreType;\n  });\n\n  p.addIntrinsic(\"map\", \n  function(): MSMap {\n    return p.mapCoreType;\n  });\n\n  p.addIntrinsic(\"number\", \n  function(): MSMap {\n    return p.numberCoreType;\n  });\n\n  p.addIntrinsic(\"funcRef\", \n  function(): MSMap {\n    return p.funcRefCoreType;\n  });\n\n}", "import { BoundFunction } from \"../../vm/funcdef\";\nimport { MSMap } from \"../../vm/msmap\";\nimport { Processor } from \"../../vm/processor\";\nimport { hashCode, equals } from \"../../vm/runtime\";\n\nexport function addIdentityIntrinsics(p: Processor) {\n\n  p.addIntrinsic(\"hash(obj)\", \n  function(obj: any): number {\n    return hashCode(obj);\n  });\n\n  p.addIntrinsic(\"refEquals(a,b\",\n  function(a: any, b: any): number {\n    let result: boolean = false;\n    if (a === null) {\n      result = (b === null);\n    } else if (typeof a === \"number\") {\n      result = (typeof b === \"number\" && a === b);\n    } else if (typeof a === \"string\") {\n      // NOTE: this does not behave like C# MiniScript, where String objects\n      // can have different references. This would suppose a major implementation\n      // change (and possibly peformance loss) and no official test covers this. \n      // So we let it stay for now.\n      result = (typeof b === \"string\" && a === b);\n    } else if (a instanceof Array) {\n      result = (b instanceof Array && a === b);\n    } else if (a instanceof MSMap) {\n      result = (b instanceof MSMap && a === b );\n    } else if (a instanceof BoundFunction) {\n      result = (b instanceof BoundFunction && a === b);\n    } else {\n      result = (equals(a,b) === 1);\n    }\n    return result ? 1 : 0;\n  });\n\n}\n", "import { Processor } from \"../../vm/processor\";\nimport { round } from \"../../vm/runtime\";\n\nexport function addMathIntrinsics(p: Processor) {\n\n  p.addIntrinsic(\"abs(x)\", \n  function(x: any): number {\n    if (typeof x === \"number\") {\n      return Math.abs(x);\n    } else {\n      return 0;\n    }\n  });\n  \n  p.addIntrinsic(\"floor(n)\", \n  function(n: any): number {\n    if (typeof n === \"number\") {\n      return Math.floor(n);\n    } else {\n      return 0;\n    }\n  });\n\n  p.addIntrinsic(\"ceil(n)\", \n  function(n: any): number {\n    if (typeof n === \"number\") {\n      return Math.ceil(n);\n    } else {\n      return 0;\n    }\n  });\n\n  p.addIntrinsic(\"round(n,decimalPlaces=0)\", \n  function(n: any, decimalPlaces: any): number {\n    const result = round(n, decimalPlaces);\n    if (result !== undefined ) {\n      return result;\n    } else {\n      return 0;\n    }\n  });\n\n  p.addIntrinsic(\"pi\", \n  function(): number {\n    return Math.PI;\n  });\n\n  p.addIntrinsic(\"sin(x)\", \n  function(x: any): number {\n    return Math.sin(x);\n  });\n\n  p.addIntrinsic(\"cos(x)\", \n  function(x: any): number {\n    return Math.cos(x);\n  });\n\n  p.addIntrinsic(\"tan(x)\", \n  function(x: any): number {\n    return Math.tan(x);\n  });\n\n  p.addIntrinsic(\"asin(x)\", \n  function(x: any): number {\n    return Math.asin(x);\n  });\n\n  p.addIntrinsic(\"acos(x)\", \n  function(x: any): number {\n    return Math.acos(x);\n  });\n\n  p.addIntrinsic(\"atan(x)\", \n  function(x: any): number {\n    return Math.atan(x);\n  });\n\n  p.addIntrinsic(\"sign(n)\", \n  function(n: any): number {\n    if (typeof n === \"number\") {\n      if (n > 0) {\n        return 1;\n      } else if (n < 0) {\n        return -1;\n      }\n    }\n    return 0;\n  });\n\n  p.addIntrinsic(\"log(x,base=10)\", \n  function(x: any, base: any): number {\n    if (typeof x === \"number\" && typeof base === \"number\") {\n      return Math.log(x) / Math.log(base);\n    }\n    return 0;\n  });\n\n  p.addIntrinsic(\"sqrt(x)\", \n  function(x: any): number {\n    if (typeof x === \"number\") {\n      return Math.sqrt(x);\n    }\n    return 0;\n  });\n\n}\n", "import { Processor } from \"../../vm/processor\";\nimport { formatValue, toStr } from \"../../vm/runtime\";\n\nexport function addPrintIntrinsic(p: Processor) {\n\n  // Accumulate text-parts here until a newline is processed\n  let stdoutBuffer: string[] = [];\n\n  p.addIntrinsic('print(s=\"\",delimiter=null)', \n  function(value: any, delimiter: any) {\n    if (delimiter === null) {\n      delimiter = \"\\n\";\n    }\n    delimiter = toStr(delimiter);\n\n    let text = formatValue(value) + delimiter;\n    const delimiterIdxAndLength = (s: string): [number,number] => {\n      let idx = s.indexOf(\"\\n\\r\");\n      if (idx >= 0) { return [idx, 2] }\n      idx = s.indexOf(\"\\r\\n\");\n      if (idx >= 0) { return [idx, 2] }\n      idx = s.indexOf(\"\\n\");\n      if (idx >= 0) { return [idx, 1] }\n      idx = s.indexOf(\"\\r\");\n      return [idx, 1];\n    }\n\n    // If the text contains newline-delimiters split it\n    // and add the snippets to the buffer. At each delimiter\n    // invoke the callback, which only deals with \"whole\"\n    // (delimited / terminated) lines.\n    while (text.length > 0) {\n      const [nextIdx, delimLen] = delimiterIdxAndLength(text);\n      if (nextIdx < 0) {\n        // No newline delimiter in text\n        // Push it to the buffer and return\n        stdoutBuffer.push(text);\n        return;\n      } else {\n        const part = text.slice(0, nextIdx);\n        // Add length to skip the matched delimiter\n        const rest = text.slice(nextIdx + delimLen);\n        text = rest;\n        stdoutBuffer.push(part);\n        // And flush, invoking callback and clearing buffer\n        const joined = stdoutBuffer.join(\"\");\n        p.stdoutCallback(joined);\n        stdoutBuffer = [];\n      }\n    }\n  });\n\n}\n", "import { MSMap } from \"../../vm/msmap\";\nimport { Processor } from \"../../vm/processor\";\nimport { toIntegerValue, getRandomInt } from \"../../vm/runtime\";\n\nexport function addRandomnessIntrinsics(p: Processor) {\n\n  p.addIntrinsic(\"rnd(seed)\", \n  function(seed: any): number {\n    if (seed !== null) {\n      seed = toIntegerValue(seed);\n      p.initRandomGenerator(seed);\n    }\n    return p.random();\n  });\n\n  p.addIntrinsic(\"shuffle(self)\", \n  function(self: any): any {  \n    if (self instanceof Array) {\n      for (let idx = self.length - 1; idx >= 1; idx--) {\n        const rndIdx = getRandomInt(p, idx+1);\n        // Swap values between current index and random index\n        const tempValue = self[rndIdx];\n        self[rndIdx] = self[idx];\n        self[idx] = tempValue;\n      }\n    } else if (self instanceof MSMap) {\n      const keys = Array.from(self.keys());\n      for (let keyIdx = keys.length - 1; keyIdx >= 1; keyIdx--) {\n        const rndIdx = getRandomInt(p, keyIdx+1);\n        // Swap values between current key in loop and random key\n        const key = keys[keyIdx];\n        const rndKey = keys[rndIdx];\n        const tempValue = self.get(rndKey);\n        self.set(rndKey, self.get(key));\n        self.set(key, tempValue);\n      }\n    }\n    return null;\n  });\n\n}\n", "import { Processor } from \"../../vm/processor\";\nimport { toNumberValue } from \"../../vm/runtime\";\n\nexport function addSchedulingIntrinsics(p: Processor) {\n\n  p.addIntrinsic(\"time\", \n  function(): number {\n    const t0 = p.executionStartTime;\n    const t1 = performance.now();\n    return (t1 - t0) / 1000.0;\n  });\n\n  p.addIntrinsic(\"wait(seconds=1.0)\", \n  function(seconds: number): Promise<any> {\n    seconds = toNumberValue(seconds);\n    const milliseconds = seconds * 1000;\n    return new Promise<any>((resolve) => {\n      // Resolve promise after amount of seconds\n      setTimeout(() => {\n        resolve(null);\n      }, milliseconds);\n    });\n  });\n\n  p.addIntrinsic(\"yield\", \n  function(): any {\n    p.yieldExecution();\n  });\n\n  p.addIntrinsic(\"exit\",\n  function() {\n    p.stopRunning();\n    return Processor.abortCallValue;\n  });\n  \n}", "import { Processor } from \"../../vm/processor\";\n\nexport function addStringIntrinsics(p: Processor) {\n\n  p.addIntrinsic(\"upper(self)\", \n  function(value: any): string |any {\n    if (typeof value === \"string\") {\n      return value.toUpperCase();\n    } else {\n      return value;\n    }\n  });\n\n  p.addIntrinsic(\"lower(self)\", \n  function(value: any): string |any {\n    if (typeof value === \"string\") {\n      return value.toLowerCase();\n    } else {\n      return value;\n    }\n  });\n\n}\n", "import { BoundFunction } from \"../vm/funcdef\";\nimport { MSMap } from \"../vm/msmap\";\nimport { Processor } from \"../vm/processor\";\nimport { addBitOperationIntrinsics } from \"./standard/bitOperations\";\nimport { addCharIntrinsics } from \"./standard/chars\";\nimport { addCollectionIntrinsics } from \"./standard/collections\";\nimport { addConversionIntrinsics } from \"./standard/conversion\";\nimport { addCoreTypesIntrinsics } from \"./standard/coreTypes\";\nimport { addIdentityIntrinsics } from \"./standard/identity\";\nimport { addMathIntrinsics } from \"./standard/math\";\nimport { addPrintIntrinsic } from \"./standard/print\";\nimport { addRandomnessIntrinsics } from \"./standard/randomness\";\nimport { addSchedulingIntrinsics } from \"./standard/scheduling\";\nimport { addStringIntrinsics } from \"./standard/string\";\n\n\nexport function addStandardIntrinsics(p: Processor) {\n  addPrintIntrinsic(p);\n  \n  addCoreTypesIntrinsics(p);\n\n  addMathIntrinsics(p);\n  addBitOperationIntrinsics(p);\n  addCharIntrinsics(p);\n  addCollectionIntrinsics(p);\n  addConversionIntrinsics(p);\n  addIdentityIntrinsics(p);\n  addRandomnessIntrinsics(p);\n  addSchedulingIntrinsics(p);\n  addStringIntrinsics(p);\n\n  // Once all other intrinsics have been created, add some of them\n  // to the base type maps.\n  addBaseTypesIntrinsics(p);\n}\n\nfunction addBaseTypesIntrinsics(p: Processor) {\n\n  const listIntrinsicNames = [\"len\", \"indexOf\", \"indexes\", \"hasIndex\", \"sum\",\n    \"sort\", \"push\", \"pull\", \"pop\", \"values\", \"insert\", \"remove\", \"replace\",\n    \"join\", \"shuffle\"];\n  const stringIntrinsicNames = [\"len\", \"indexOf\", \"indexes\", \"hasIndex\", \"upper\", \n    \"lower\", \"values\", \"insert\", \"remove\", \"replace\", \"split\", \"val\", \"code\"];\n  const mapIntrinsicNames = [\"len\", \"indexOf\", \"indexes\", \"hasIndex\", \"sum\",\n    \"push\", \"pull\", \"pop\", \"values\", \"remove\", \"replace\", \"shuffle\"];\n\n  const getFn = (name: string): BoundFunction => {\n    const optFn = p.globalContext.getOpt(name);\n    if (optFn !== undefined) {\n      return optFn;\n    } else {\n      throw new Error(\"Intrinsic not found: \" + name);\n    }\n  };\n\n  const importIntrinsics = (targetList: MSMap, intrinsicNames: string[]) => {\n    for (let fnName of intrinsicNames) {\n      const boundFn = getFn(fnName);\n      const argNames = boundFn.funcDef.argNames;\n      if (argNames.length < 1 || argNames[0] !== \"self\") {\n        throw new Error(`First parameter of ${fnName} must be 'self'. Found: ${argNames}`);\n      }\n      p.attachExistingIntrinsic(targetList, fnName, boundFn);\n    }\n  };\n\n  importIntrinsics(p.listCoreType, listIntrinsicNames);\n  importIntrinsics(p.mapCoreType, mapIntrinsicNames);\n  importIntrinsics(p.stringCoreType, stringIntrinsicNames);\n}", "import { Token } from \"./tokenizerModel\";\n\nexport class ParserError extends Error {\n  constructor(\n    message: string, \n    public readonly position: Pos) {\n      const msg = `Compiler Error: ${message} [line ${position.row}]`;\n      super(msg);\n    }\n}\n\n// Location in the source-code.\nexport class SrcLocation {\n\n  public readonly start: Pos;\n  public readonly end: Pos;\n  public readonly source: string;\n\n  constructor(start: Pos, end: Pos, source: string | undefined){\n    if (start.idx > end.idx) {\n      throw new Error(\"Start must be less than end\");\n    }\n    this.start = start;\n    this.end = end;\n    if (source !== undefined) {\n      this.source = source;\n    } else {\n      this.source = \"inline\";\n    }\n  }\n\n  static forTokenRange(firstToken: Token, lastToken: Token): SrcLocation {\n    const firstLocation = firstToken.location;\n    const lastLocation = lastToken.location;\n    return firstLocation.upTo(lastLocation);\n  }\n\n  upTo(otherLocation: SrcLocation): SrcLocation {\n    if (otherLocation.start.idx < this.end.idx) {\n      throw new Error(\"The other location must be further ahead than the first one\");\n    }\n    const newStart = this.start;\n    const newEnd = otherLocation.end;\n    const newLocation = new SrcLocation(newStart, newEnd, this.source);\n    return newLocation;\n  }\n\n  toString(): string {\n    return `[(row:${this.start.row},col:${this.start.col}) to (row:${this.end.row},col:${this.end.col})]`\n  }\n\n}\n\nexport class Pos {\n\n  idx: number;\n  col: number;\n  row: number;\n\n  constructor(idx: number, col: number, row: number) {\n    this.idx = idx;\n    this.col = col;\n    this.row = row;\n  }\n\n  copy() {\n    return new Pos(this.idx, this.col, this.row);\n  }\n\n  advance() {\n    this.idx=this.idx + 1\n    this.col=this.col + 1\n  }\n\n  moveToNewLine() {\n    this.idx=this.idx\n    this.col=1\n    this.row=this.row + 1\n  }\n\n  toString() {\n    return `(idx=${this.idx},row=${this.row},col=${this.col})`\n  }\n}\n", "import { SrcLocation } from \"./commonModel\"\nimport { TokenType } from \"./tokenTypes\"\n\nexport interface Token {\n  tokenType: TokenType\n  location: SrcLocation\n  afterSpace: boolean\n}\n\nexport class SimpleToken implements Token {\n\n  tokenType: TokenType\n  location: SrcLocation\n  afterSpace: boolean\n\n  constructor(tokenType: TokenType, location: SrcLocation, afterSpace: boolean) {\n    this.tokenType = tokenType;\n    this.location = location;\n    this.afterSpace = afterSpace;\n  }\n\n  toString(): string {\n    return `SimpleToken(tokenType=${TokenType[this.tokenType]},position=${this.location.toString()},afterSpace=${this.afterSpace})`\n  }\n}\n\nexport class LiteralToken<T> implements Token {\n  value: T\n  tokenType: TokenType\n  location: SrcLocation\n  afterSpace: boolean\n\n  constructor(tokenType: TokenType, value: T, position: SrcLocation, afterSpace: boolean) {\n    this.tokenType = tokenType;\n    this.value = value;\n    this.location = position;\n    this.afterSpace = afterSpace;\n  }\n\n  toString(): string {\n    let strValue: string;\n    if (this.tokenType == TokenType.STRING_LITERAL) {\n      strValue = `\"${this.value}\"`;\n    } else {\n      strValue = `${this.value}`;\n    }\n    return `LiteralToken(tokenType=${TokenType[this.tokenType]},value=${strValue},position=${this.location.toString()},afterSpace=${this.afterSpace})`\n  }\n}\n\nexport class StringLiteral extends LiteralToken<string> {\n  constructor(value: string, location: SrcLocation, afterSpace: boolean) {\n    super(TokenType.STRING_LITERAL, value, location, afterSpace);\n  }\n}\n\nexport class IntLiteral extends LiteralToken<number> {\n  constructor(value: number, location: SrcLocation, afterSpace: boolean) {\n    super(TokenType.INT_LITERAL, value, location, afterSpace);\n  }\n}\n\nexport class FloatLiteral extends LiteralToken<number> {\n  constructor(value: number, location: SrcLocation, afterSpace: boolean) {\n    super(TokenType.FLOAT_LITERAL, value, location, afterSpace);\n  }\n}\n\nexport class Identifier implements Token {\n  value: string\n  tokenType: TokenType\n  location: SrcLocation\n  afterSpace: boolean\n\n  constructor (value: string, location: SrcLocation, afterSpace: boolean) {\n    this.tokenType = TokenType.IDENTIFIER_TK;\n    this.value = value;\n    this.location = location;\n    this.afterSpace = afterSpace;\n  }\n\n  toString(): string {\n    return `Identifier(value=\"${this.value}\",position=${this.location.toString()},afterSpace=${this.afterSpace})`\n  }\n}\n\nexport class EofToken implements Token {\n  tokenType: TokenType\n  location: SrcLocation\n  afterSpace: boolean\n\n  constructor (location: SrcLocation, afterSpace: boolean) {\n    this.tokenType = TokenType.EOF;\n    this.location = location;\n    this.afterSpace = afterSpace;\n  }\n\n  toString(): string {\n    return `EofToken(position=${this.location.toString()},afterSpace=${this.afterSpace})`\n  }\n}\n", "import { Pos, SrcLocation, ParserError } from \"./commonModel\";\nimport { Token, SimpleToken, Identifier, StringLiteral, IntLiteral, FloatLiteral, EofToken } from \"./tokenizerModel\";\nimport { TokenType } from \"./tokenTypes\";\n\n// Used internally by the tokenizer\nclass NumberLiteral {\n  \n  public readonly isInt: boolean\n  public readonly numberValue: number\n\n  constructor(isInt: boolean, numberValue: number) {\n    this.isInt = isInt\n    this.numberValue = numberValue\n  }\n}\n\nexport class Tokenizer {\n\n  private readonly input: string;\n  private readonly source: string | undefined;\n  private pos: Pos;\n  private startPos: Pos;\n  private _currentChar: string = '\\u0000'\n  private _peek2Str: string = \"\"\n  private _lastTokenIsSpace: boolean = false\n\n  private tokens: Token[] = []\n\n  private readonly keywordTable: { [id:string]: TokenType } = {\n    \"if\": TokenType.KW_IF,\n    \"else\": TokenType.KW_ELSE,\n    \"then\": TokenType.KW_THEN,\n    \"while\": TokenType.KW_WHILE,\n    \"for\": TokenType.KW_FOR,\n    \"function\": TokenType.KW_FUNCTION,\n    \"break\": TokenType.KW_BREAK,\n    \"continue\": TokenType.KW_CONTINUE,\n    \"end\": TokenType.KW_END,\n    \"return\": TokenType.KW_RETURN,\n    \"super\": TokenType.KW_SUPER,\n    \"true\": TokenType.KW_TRUE,\n    \"false\": TokenType.KW_FALSE,\n    \"null\": TokenType.KW_NULL,\n    \"in\": TokenType.KW_IN,\n    \"not\": TokenType.OP_NOT,\n    \"or\": TokenType.OP_OR,\n    \"and\": TokenType.OP_AND,\n    \"isa\": TokenType.OP_ISA,\n    \"new\": TokenType.KW_NEW,\n  }\n\n  constructor(input: string, source: string | undefined = undefined) {\n    this.input = input;\n    this.pos = new Pos(0, 1, 1);\n    this.startPos = this.pos.copy();\n    this.source = source;\n  }\n\n  tokenize(): Token[] {\n    this.updateCharAndPeek()\n\n    while (this.hasInput()) {\n      this.processNextToken()\n    }\n    this.addEofToken(this.location())\n\n    const tokensCombined = this.combinedTokens(this.tokens)\n\n    return tokensCombined\n  }\n\n  private idx(): number {\n    return this.pos.idx;\n  }\n\n  private saveStartPos() {\n    this.startPos = this.pos.copy();\n  }\n\n  private location(): SrcLocation {\n    const endPos = this.pos.copy();\n    const loc = new SrcLocation(this.startPos, endPos, this.source);\n    return loc;\n  }\n\n  private hasInput(): boolean {\n    return this.idx() < this.input.length\n  }\n\n  private processNextToken()  {\n    const ch: string = this.getChar()\n\n    if (this.isSpaceChar(ch)) {\n      this.processSpaces()\n    } else if(ch == '\\n' || ch =='\\r') {\n      this.processNewline()\n    } else if(ch == '\\\"') {\n      this.processStringLiteral()\n    } else if(this.isNumericChar(ch)) {\n      // This could be int or float - it's decided later\n      this.processNumberLiteral()\n    } else if (ch == ';') {\n      this.processCharToken(TokenType.SEMICOLON)\n    } else if (ch == ':') {\n      this.processCharToken(TokenType.COLON)\n    } else if (ch == '.') {\n      this.processDot()\n    } else if(ch == ',') {\n      this.processCharToken(TokenType.COMMA)\n    } else if(ch == '(') {\n      this.processCharToken(TokenType.OPEN_ROUND)\n    } else if(ch == ')') {\n      this.processCharToken(TokenType.CLOSE_ROUND)\n    } else if(ch == '[') {\n      this.processCharToken(TokenType.OPEN_SQUARE)\n    } else if(ch == ']') {\n      this.processCharToken(TokenType.CLOSE_SQUARE)\n    } else if(ch == '{') {\n      this.processCharToken(TokenType.OPEN_CURLY)\n    } else if(ch == '}') {\n      this.processCharToken(TokenType.CLOSE_CURLY)\n    } else if(this.peek2Chars() == \"//\") {\n      this.processComment()\n    } else if(this.isOperatorChar(ch)) {\n      this.processOperator()\n    } else if(this.isIdentifierStartChar(ch)) {\n      this.processSymbol()\n    } else {\n      throw new ParserError(`got Unknown(${ch}) where EOL is required`, this.pos)\n    }\n  }\n\n  private getChar(): string {\n    return this._currentChar\n  }\n\n  /**\n   * Tries to peek N-amount of characters, cutting before if not possible\n   * */\n  private peek2Chars(): string {\n    return this._peek2Str\n  }\n\n  private advance(amount: number = 1) {\n    let i = 0;\n    while (i < amount) {\n      this.pos.advance();\n      i += 1;\n    }\n\n    if (this.hasInput()) {\n      this.updateCharAndPeek()\n    }\n  }\n\n  private addToken(newToken: Token) {\n    this.tokens.push(newToken);\n  }\n\n  private updateCharAndPeek() {\n    // Update chars / peek\n    this._currentChar = this.input[this.idx()]\n    if (this.idx() + 1 < this.input.length) {\n      const afterCurrent = this.input[this.idx() + 1]\n      this._peek2Str = `${this._currentChar}${afterCurrent}`\n    } else {\n      this._peek2Str = `${this._currentChar}`\n    }\n  }\n\n  private processAfterSpaces(): boolean {\n    const afterSpaces = this._lastTokenIsSpace\n    this._lastTokenIsSpace = false\n    return afterSpaces\n  }\n\n  private isSpaceChar(ch: string): boolean {\n    return ch == ' ' || ch == '\\t'\n  }\n\n  private isIdentifierStartChar(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') ||\n      (ch >= 'A' && ch <= 'Z') ||\n      (ch == '_') ||\n      // Support unicode\n      (ch > '\\u009F')\n  }\n\n  private isIdentifierChar(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') ||\n      (ch >= 'A' && ch <= 'Z') ||\n      (ch >= '0' && ch <= '9') ||\n      (ch == '_') ||\n      // Support unicode\n      (ch > '\\u009F')\n  }\n\n  private isOperatorChar(ch: string): boolean {\n    return ch == '=' ||\n      ch == '!' ||\n      ch == '@' ||\n      ch == '^' ||\n      ch == '<' ||\n      ch == '>' ||\n      ch == '/' ||\n      ch == '*' ||\n      ch == '%' ||\n      ch == '+' ||\n      ch == '-'\n  }\n\n  private isNumericChar(ch: string): boolean {\n    return ch >= '0' && ch <= '9'\n  }\n\n  private processSpaces() {\n    const spaces = this.consumeChars(this.isSpaceChar)\n    if (spaces.length > 0) {\n      this._lastTokenIsSpace = true\n    }\n   }\n\n  private processNewline() {\n    const peek2 = this.peek2Chars()\n    const ch = this.getChar()\n    if (peek2 == \"\\n\\r\" || peek2 == \"\\r\\n\") {\n      this.advance(2)\n    } else if (ch == '\\n' || ch == '\\r') {\n      this.advance()\n    } else {\n      throw new ParserError(\"Expected newline character\", this.pos)\n    }\n    this.addSimpleToken(TokenType.NEWLINE)\n    this.pos.moveToNewLine()\n  }\n\n  private processSymbol() {\n    this.saveStartPos();\n    const symbolValue: string = this.fetchSymbol()\n    if (symbolValue in this.keywordTable) {\n      const tokenType = this.keywordTable[symbolValue]\n      this.addSimpleToken(tokenType)\n    } else {\n      this.addIdentifierToken(symbolValue)\n    }\n  }\n\n  private processOperator() {\n    this.saveStartPos();\n\n    const peek1 = this.getChar()\n    const peek2 = this.peek2Chars()\n    let charsToAdvance = 0;\n    let tokenTypeToAdd: TokenType | null = null;\n\n    // Try to handle 2-char operators first\n    switch(peek2) {\n      case \"==\":\n        charsToAdvance = 2;\n        tokenTypeToAdd = TokenType.OP_EQUALS;\n        break;\n      case \"!=\":\n        charsToAdvance = 2;\n        tokenTypeToAdd = TokenType.OP_NOT_EQUALS;\n        break;\n      case \"<=\":\n        charsToAdvance = 2;\n        tokenTypeToAdd = TokenType.OP_LESS_EQUALS;\n        break;\n      case \">=\":\n        charsToAdvance = 2;\n        tokenTypeToAdd = TokenType.OP_GREATER_EQUALS;\n        break;\n      case \"+=\":\n        // Not really an operator, but handled here\n        charsToAdvance = 2;\n        tokenTypeToAdd = TokenType.PLUS_ASSIGN;\n        break;\n      case \"-=\":\n        // Not really an operator, but handled here\n        charsToAdvance = 2;\n        tokenTypeToAdd = TokenType.MINUS_ASSIGN;\n        break; \n      case \"*=\":\n        // Not really an operator, but handled here\n        charsToAdvance = 2;\n        tokenTypeToAdd = TokenType.MULT_ASSIGN;\n        break;\n      case \"/=\":\n        // Not really an operator, but handled here\n        charsToAdvance = 2;\n        tokenTypeToAdd = TokenType.DIV_ASSIGN;\n        break; \n      case \"%=\":\n        // Not really an operator, but handled here\n        charsToAdvance = 2;\n        tokenTypeToAdd = TokenType.MOD_ASSIGN;\n        break;\n      case \"^=\":\n        // Not really an operator, but handled here\n        charsToAdvance = 2;\n        tokenTypeToAdd = TokenType.POW_ASSIGN;\n        break; \n      default:\n        // Nothing, we'll try with one-char below\n        break;\n    }\n\n    // If nothing matched with 2 chars, try with one\n    if (tokenTypeToAdd === null) {\n      switch(peek1) {\n        case '=':\n          // Not really an operator, but handled here\n          charsToAdvance = 1;\n          tokenTypeToAdd = TokenType.ASSIGN;\n          break;\n        case '<':\n          charsToAdvance = 1;\n          tokenTypeToAdd = TokenType.OP_LESS;\n          break;\n        case '>':\n          charsToAdvance = 1;\n          tokenTypeToAdd = TokenType.OP_GREATER;\n          break;\n        case '+':\n          charsToAdvance = 1;\n          tokenTypeToAdd = TokenType.OP_PLUS;\n          break;\n        case '-':\n          charsToAdvance = 1;\n          tokenTypeToAdd = TokenType.OP_MINUS;\n          break;\n        case '*':\n          charsToAdvance = 1;\n          tokenTypeToAdd = TokenType.OP_MULT;\n          break;\n        case '/':\n          charsToAdvance = 1;\n          tokenTypeToAdd = TokenType.OP_DIV;\n          break;\n        case '%':\n          charsToAdvance = 1;\n          tokenTypeToAdd = TokenType.OP_MOD;\n          break;\n        case '^':\n          charsToAdvance = 1;\n          tokenTypeToAdd = TokenType.OP_POW;\n          break;\n        case '@':\n          charsToAdvance = 1;\n          tokenTypeToAdd = TokenType.OP_FUNCREF;\n          break;\n        default:\n          throw new ParserError(\"Unhandled operator: \" + peek1, this.startPos)\n      }\n    }\n\n    if (tokenTypeToAdd != null) {\n      this.addSimpleToken(tokenTypeToAdd);\n      this.advance(charsToAdvance);\n    }\n  }\n\n  private processStringLiteral() {\n    this.saveStartPos();\n    const value = this.fetchStringLiteral()\n    this.addStringLiteralToken(value, this.location())\n  }\n\n  private fetchStringLiteral() {\n    let chars = \"\"\n    let closed = false\n\n    // Skip opening quote\n    this.advance()\n\n    // Process until a new, lone double-quote char is found\n    // Pairs of double-quote chars (i.e. \"\") are escaped double-quotes (i.e. \\\")\n    while (this.hasInput() && !closed) {\n      const peek2 = this.peek2Chars()\n      const ch = this.getChar()\n      if (peek2 == \"\\\"\\\"\") {\n        chars += '\\\"'\n        this.advance(2)\n      } else if (ch == '\\\"') {\n        closed = true\n        this.advance()\n      } else {\n        chars += ch\n        this.advance()\n      }\n    }\n\n    if (!closed) {\n      throw new ParserError(\"Unterminated string literal\", this.startPos)\n    }\n\n    return chars\n  }\n\n  /**\n   * Could be a dot for accessing a property, but could also be part of a float literal.\n   *\n   * It is part of a float literal if followed by a number\n   * */\n  private processDot() {\n    this.saveStartPos();\n    const nextChars = this.peek2Chars()\n    \n    if (nextChars.length > 1 && this.isNumericChar(nextChars[1])) {\n      this.processNumberLiteral()\n    } else {\n      this.processCharToken(TokenType.DOT)\n    }\n  }\n\n  /**\n   * Consume numeric chars until a dot or a non-numeric char is found.\n   * If dot found, consume until non-numeric char is found.\n   */\n  private processNumberLiteral() {\n    this.saveStartPos();\n    const value = this.fetchNumberLiteral()\n    if (value.isInt) {\n      this.addIntLiteralToken(value.numberValue, this.location())\n    } else {\n      this.addFloatLiteralToken(value.numberValue, this.location())\n    }\n  }\n\n  private fetchNumberLiteral(): NumberLiteral {\n    let consumingFloatingPart = false\n    let intDigits = \"\"\n    let floatDigits = \"\"\n    let fetchingChars = true\n    let exponentPart = \"\"\n\n    while (this.hasInput() && fetchingChars) {\n      const ch = this.getChar()\n      if (this.isNumericChar(ch)) {\n        if (consumingFloatingPart) {\n          floatDigits += ch\n          this.advance()\n        } else {\n          intDigits += ch\n          this.advance()\n        }\n      } else if (ch == '.') {\n        if (consumingFloatingPart) {\n          throw new ParserError(\"Unexpected repeated dot\", this.startPos)\n        }\n        consumingFloatingPart = true\n        this.advance()\n      } else if (ch == 'e' || ch == 'E') {\n        exponentPart = this.parseExponentPart();\n        fetchingChars = false\n      } else {\n        fetchingChars = false\n      }\n    }\n\n    let numberValue: number;\n    let isInt: boolean; \n\n    if (floatDigits.length > 0) {\n      numberValue = parseFloat(`${intDigits}.${floatDigits}${exponentPart}`);\n      isInt = false;\n    } else {\n      numberValue = parseInt(`${intDigits}${exponentPart}`);\n      isInt = true;\n    }\n\n    return new NumberLiteral(isInt, numberValue);\n  }\n\n  private parseExponentPart(): string {\n    const eChar = this.getChar();\n    this.advance();\n\n    const signChar = this.consumeAny(\"+\", \"-\");\n    if (!signChar) {\n      throw new Error(\"Expected +/- after exponential letter\");\n    }\n\n    let exponentPart: string = \"\";\n    \n    while (this.hasInput()) {\n      const optDigit = this.consumeAny('0','1','2','3','4','5','6','7','8','9');\n      if (optDigit !== undefined) {\n        exponentPart += optDigit;\n      } else {\n        break;\n      }\n    }\n\n    if (exponentPart.length == 0) {\n      throw new Error(\"Expected exponent in exponential notation\");\n    }\n    \n    return `${eChar}${signChar}${exponentPart}`;\n  }\n\n  /**\n   * Advance until newline found\n   */\n  private processComment() {\n    let insideComment = true\n    while (this.hasInput() && insideComment) {\n      const ch = this.getChar()\n      const peek2 = this.peek2Chars()\n      if (peek2 == \"\\n\\r\" || peek2 == \"\\r\\n\") {\n        insideComment = false\n      } else if (ch == '\\n' || ch == '\\r') {\n        insideComment = false\n      } else {\n        // Inside comment, advance one char\n        this.advance()\n      }\n    }\n  }\n\n  private consumeAny(...chars: string[]): string|undefined {\n    const c = this.getChar();\n    for (let i = 0; i < chars.length; i++) {\n      if (chars[i] === c) {\n        this.advance();\n        return c;\n      }\n    }\n    // No match found\n    return undefined;\n  }\n\n  private addSimpleToken(tokenType: TokenType) {\n    const afterSpace = this.processAfterSpaces()\n    const newToken: Token = new SimpleToken(\n      tokenType,\n      this.location(),\n      afterSpace)\n    this.addToken(newToken)\n  }\n\n  private addIdentifierToken(identifierValue: string) {\n    const afterSpace = this.processAfterSpaces()\n    const newToken = new Identifier(\n      identifierValue,\n      this.location(),\n      afterSpace)\n    this.addToken(newToken)\n  }\n\n  private addStringLiteralToken(stringValue: string, tokenLocation: SrcLocation) {\n    const afterSpace = this.processAfterSpaces()\n    const newToken = new StringLiteral(\n      stringValue,\n      tokenLocation,\n      afterSpace)\n    this.addToken(newToken)\n  }\n\n  private addIntLiteralToken(intValue: number, tokenLocation: SrcLocation) {\n    const afterSpace = this.processAfterSpaces()\n    const newToken = new IntLiteral(\n      intValue,\n      tokenLocation,\n      afterSpace)\n    this.addToken(newToken)\n  }\n\n  private addFloatLiteralToken(floatValue: number, tokenLocation: SrcLocation) {\n    const afterSpace = this.processAfterSpaces()\n    const newToken = new FloatLiteral(\n      floatValue,\n      tokenLocation,\n      afterSpace)\n    this.addToken(newToken)\n  }\n\n  private addEofToken(tokenLocation: SrcLocation) {\n    const afterSpace = this.processAfterSpaces()\n    const newToken = new EofToken(\n      tokenLocation,\n      afterSpace)\n    this.addToken(newToken)\n  }\n\n  private fetchSymbol(): string {\n    const predicate = (ch: string) => this.isIdentifierChar(ch);\n    const value = this.consumeChars(predicate)\n    return value\n  }\n\n  /**\n   * Consume chars as long as the predicate is true\n   */\n  private consumeChars(predicate : Function): string {\n    let chars = \"\"\n    let fetchingChars = true\n    while(this.hasInput() && fetchingChars) {\n      const ch = this.getChar()\n      if(predicate(ch)) {\n        // Put into buffer\n        chars += ch\n        this.advance()\n      } else {\n        fetchingChars = false\n      }\n    }\n    return chars\n  }\n\n  private processCharToken(tokenType: TokenType) {\n    this.saveStartPos();\n    this.advance();\n    this.addSimpleToken(tokenType)\n  }\n\n  private combinedTokens(tokens: Token[]): Token[] {\n    let combinedTokens: Token[] = []\n\n    let idx = 0\n    while (idx < tokens.length) {\n\n      const token = tokens[idx]\n      let optNextToken: Token | null;\n\n      if (idx + 1 < tokens.length) {\n        optNextToken = tokens[idx + 1]\n      } else {\n        optNextToken = null\n      }\n\n      let tokenToAdd: Token = token\n\n      if (token.tokenType == TokenType.KW_END) {\n        let secondTokenFound: boolean = false\n        if (optNextToken != null) {\n          if (optNextToken.tokenType == TokenType.KW_IF) {\n            const newLocation = token.location.upTo(optNextToken.location);\n            tokenToAdd = new SimpleToken(TokenType.KW_END_IF, newLocation, token.afterSpace)\n            secondTokenFound = true\n          } else if (optNextToken.tokenType == TokenType.KW_WHILE) {\n            const newLocation = token.location.upTo(optNextToken.location);\n            tokenToAdd = new SimpleToken(TokenType.KW_END_WHILE, newLocation, token.afterSpace)\n            secondTokenFound = true\n          } else if (optNextToken.tokenType == TokenType.KW_FOR) {\n            const newLocation = token.location.upTo(optNextToken.location);\n            tokenToAdd = new SimpleToken(TokenType.KW_END_FOR, newLocation, token.afterSpace)\n            secondTokenFound = true\n          } else if (optNextToken.tokenType == TokenType.KW_FUNCTION) {\n            const newLocation = token.location.upTo(optNextToken.location);\n            tokenToAdd = new SimpleToken(TokenType.KW_END_FUNCTION, newLocation, token.afterSpace)\n            secondTokenFound = true\n          }\n        }\n        if (!secondTokenFound) {\n          throw new ParserError(\"Expected token of type if / for / while / function after 'end\", token.location.start);\n        }\n      // Combine \"ELSE\" + \"IF\" to \"ELSE IF\"\n      } else if (token.tokenType == TokenType.KW_ELSE) {\n        if (optNextToken != null && optNextToken instanceof SimpleToken) {\n          if (optNextToken.tokenType == TokenType.KW_IF) {\n            const newLocation = token.location.upTo(optNextToken.location);\n            tokenToAdd = new SimpleToken(TokenType.KW_ELSE_IF, newLocation, token.afterSpace)\n          }\n        }\n      }\n\n      if (tokenToAdd != token) {\n        idx += 2\n      } else {\n        idx += 1\n      }\n\n      combinedTokens.push(tokenToAdd)\n    }\n\n    return combinedTokens\n  }\n\n} // Tokenizer\n\n", "import { SrcLocation, ParserError } from \"./commonModel\";\nimport { Statement, IfStatement, Expression, ConditionedStatements, WhileStatement, ForStatement, BreakStatement, ContinueStatement, ReturnStatement, FunctionCallStatement, ExpressionStatement, AssignmentStatement, IdentifierExpr, DotAccessExpr, IndexedAccessExpr, MathAssignmentStatement, LogicExpr, UnaryExpr, BinaryExpr, ChainedComparisonExpr, Literal, FunctionRefExpr, FunctionCallExpr, ListSlicingExpr, GroupingExpr, SuperExpr, ListExpr, MapExpr, FunctionBodyExpr, Argument } from \"./parserModel\";\nimport { Tokenizer } from \"./tokenizer\";\nimport { Token, Identifier, LiteralToken } from \"./tokenizerModel\";\nimport { TokenType, toOfficialImplTokenName } from \"./tokenTypes\";\n\nclass ParsingContext {\n\n  constructor(\n    public insideFunction: boolean = false,\n    public insideLoop: boolean = false,\n    public insideSingleLineThen: boolean = false,\n    public parsingStatementExpr: boolean = false) {}\n\n  enterFunction(): ParsingContext {\n    const copy = this.copy();\n    copy.insideFunction = true;\n    return copy;\n  }\n\n  enterLoop(): ParsingContext {\n    const copy = this.copy();\n    copy.insideLoop = true;\n    return copy;\n  }\n\n  enterSingleLineThen(): ParsingContext {\n    const copy = this.copy();\n    copy.insideSingleLineThen = true;\n    return copy;\n  }\n\n  enterParsingStatementExpr(): ParsingContext {\n    const copy = this.copy();\n    copy.parsingStatementExpr = true;\n    return copy;\n  }\n\n  leaveParsingStatementExpr(): ParsingContext {\n    const copy = this.copy();\n    copy.parsingStatementExpr = false;\n    return copy;\n  }\n\n  private copy(): ParsingContext {\n    return new ParsingContext(\n      this.insideFunction,\n      this.insideLoop,\n      this.insideSingleLineThen,\n      this.parsingStatementExpr)\n  }\n}\n\nexport class Parser {\n\n  private readonly defaultContext = new ParsingContext()\n  private current: number = 0\n  private tokens: Token[] = []\n\n  constructor(private input: string) {}\n\n  parse(): Statement[] {\n    this.tokens = this.tokenize(this.input)\n    const statements = this.parseUntil([], this.defaultContext)\n    return statements\n  }\n\n  private tokenize(input: string): Token[] {\n    const tokenizer = new Tokenizer(input = input)\n    const tokens = tokenizer.tokenize()\n    const tokensWithSomeLineBreaksRemoved = this.removeSuperfluousLineBreaks(tokens)\n    return tokensWithSomeLineBreaksRemoved\n  }\n\n  /**\n   * Some expressions make it possible to insert newlines and have them continue\n   * in the next line.\n   *\n   * For example:\n   *\n   * [1, 2,\n   *  3 ]\n   *\n   * Or:\n   *\n   * x ==\n   * 3\n   *\n   * This function eliminates those newline tokens so that parsing\n   * can proceed in a normal way, as if they were not there to begin with.\n   * */\n  //  - comma (in call expr / statement, in map / list)\n  //  - open brackets (or all kinds)\n  //  - colon (for slicing)\n  //  - not\n  //  - unary minus\n  //  - new\n  //  - @ (address of)\n  //  - power ^\n  //  - isa\n  //  - dot (call)\n  //  - logic operators\n  //  - comparison operator\n  //  - binary (algebr.) operators\n  private removeSuperfluousLineBreaks(tokens: Token[]): Token[] {\n    const typesThatAllowLineBreaks = [\n      TokenType.COMMA,\n      TokenType.OPEN_ROUND,\n      TokenType.OPEN_SQUARE,\n      TokenType.OPEN_CURLY,\n      TokenType.COLON,\n      TokenType.OP_NOT,\n      TokenType.KW_NEW,\n      TokenType.OP_FUNCREF,\n      TokenType.OP_POW,\n      TokenType.OP_ISA,\n      TokenType.DOT,\n      TokenType.OP_LESS,\n      TokenType.OP_LESS_EQUALS,\n      TokenType.OP_GREATER,\n      TokenType.OP_GREATER_EQUALS,\n      TokenType.OP_EQUALS,\n      TokenType.OP_NOT_EQUALS,\n      TokenType.OP_PLUS,\n      TokenType.OP_MINUS,\n      TokenType.OP_MULT,\n      TokenType.OP_DIV,\n      TokenType.OP_MOD,\n      TokenType.OP_AND,\n      TokenType.OP_OR,\n      TokenType.ASSIGN,\n      TokenType.PLUS_ASSIGN,\n      TokenType.MINUS_ASSIGN,\n      TokenType.MULT_ASSIGN,\n      TokenType.DIV_ASSIGN,\n      TokenType.MOD_ASSIGN,\n      TokenType.POW_ASSIGN,\n    ]\n\n    let cleanedUpTokens: Token[] = []\n    let idx = 0\n\n    while (idx < tokens.length) {\n      const token = tokens[idx]\n      const tokenType = token.tokenType\n\n      if (typesThatAllowLineBreaks.includes(tokenType)) {\n        // Add\n        cleanedUpTokens.push(token)\n        // Advance\n        idx += 1\n        // Consume newlines\n        let shouldConsume = true\n        while (shouldConsume && idx < tokens.length) {\n          const maybeNewLine = tokens[idx]\n          if (maybeNewLine.tokenType == TokenType.NEWLINE) {\n            idx += 1\n          } else {\n            shouldConsume = false\n          }\n        }\n      } else {\n        // Add\n        cleanedUpTokens.push(token)\n        // Advance\n        idx += 1\n      }\n    }\n\n    return cleanedUpTokens\n  }\n\n  private parseUntil(stoppingTokenTypes: TokenType[], context: ParsingContext): Statement[] {\n    let shouldContinue = true\n    let statements: Statement[] = []\n\n    while (!this.isAtEnd() && shouldContinue) {\n      // Discard newlines / semicolons at this stage\n      // (they are still useful as part of some statements though, e.g. after a while condition)\n      if (this.tokenMatch(TokenType.NEWLINE) || this.tokenMatch(TokenType.SEMICOLON)) {\n        // discard / skip\n      } else {\n        // Check if we reached a \"stopping\" token type\n        // (we might be in the middle of an if / function block)\n        for (let stoppingTokenType of stoppingTokenTypes) {\n          if (this.check(stoppingTokenType)) {\n            shouldContinue = false\n          }\n        }\n\n        // Only parse statement if we did not reach a stopping token-type\n        if (shouldContinue) {\n          const s = this.statement(context)\n          statements.push(s)\n        }\n      }\n    }\n\n    return statements\n  }\n\n  private statement(context: ParsingContext): Statement {\n    if (this.tokenMatch(TokenType.KW_IF)) {\n      return this.ifStatement(context)\n    } else if (this.tokenMatch(TokenType.KW_WHILE)) {\n      return this.whileStatement(context)\n    } else if (this.tokenMatch(TokenType.KW_FOR)) {\n      return this.forStatement(context)\n    } else {\n      return this.nonBlockStatement(context)\n    }\n  }\n\n  /**\n   * These statements can be appear as part of single-line statements\n   * */\n  private nonBlockStatement(context: ParsingContext): Statement {\n    if (this.tokenMatch(TokenType.KW_BREAK)) {\n      return this.breakStatement(context)\n    } else if (this.tokenMatch(TokenType.KW_CONTINUE)) {\n      return this.continueStatement(context)\n    } else if (this.tokenMatch(TokenType.KW_RETURN)) {\n      return this.returnStatement(context)\n    } else {\n      const assignmentTokenTypes = [\n        TokenType.ASSIGN,\n        TokenType.PLUS_ASSIGN,\n        TokenType.MINUS_ASSIGN,\n        TokenType.MULT_ASSIGN,\n        TokenType.DIV_ASSIGN,\n        TokenType.MOD_ASSIGN,\n        TokenType.POW_ASSIGN,\n      ];\n      const optTokenType = this.findTokenWithinStatementBoundary(assignmentTokenTypes);\n      if (optTokenType === TokenType.ASSIGN) {\n        // Looks like an assignment\n        return this.assignmentStatement(context);\n      } else if(optTokenType !== null) {\n        // Looks like a math-assignment\n        return this.mathAssignmentStatement(optTokenType, context);\n      } else {\n        return this.expressionStatement(context);\n      }\n    }\n  }\n\n  private ifStatement(context: ParsingContext): IfStatement {\n    const condition = this.expression(context)\n    this.consume(TokenType.KW_THEN, \"Expected 'then' after condition. Found: \" + this.peek())\n\n    // Decide here: if next token is NEWLINE / SEMICOLON then we have a multi-line if / then / else\n    // Otherwise treat a single-line-if\n    if (this.tokenMatch(TokenType.NEWLINE, TokenType.SEMICOLON)) {\n      // Treat as multi-line if then / [else if]* / [else] / end if\n      return this.multiLineIf(condition, context)\n    } else {\n      return this.singleLineIf(condition, context)\n    }\n  }\n\n  private multiLineIf(condition: Expression, context: ParsingContext): IfStatement {\n    // Consume statements until \"else\" or \"end if\" found - don't consume ending token\n    const ifStatements = this.parseUntil([TokenType.KW_ELSE_IF, TokenType.KW_ELSE, TokenType.KW_END_IF], context)\n    const ifBranch = new ConditionedStatements(condition, ifStatements)   \n\n    // ELSE-IF(s)\n    let elseIfs: ConditionedStatements[] = []\n    while (this.tokenMatch(TokenType.KW_ELSE_IF)) {\n      let elseIfCondition = this.expression(context)\n      this.consume(TokenType.KW_THEN, \"Expected 'then' after condition in else-if\")\n      const elseIfStatements = this.parseUntil([TokenType.KW_ELSE_IF, TokenType.KW_ELSE, TokenType.KW_END_IF], context)\n      const elseIf = new ConditionedStatements(elseIfCondition, elseIfStatements)\n      elseIfs.push(elseIf)\n    }\n\n    // ELSE: consume statements until \"end if found\"\n    let elseBranch: Statement[];\n    if (this.tokenMatch(TokenType.KW_ELSE)) {\n      elseBranch = this.parseUntil([TokenType.KW_END_IF], context)\n    } else {\n      elseBranch = []\n    }\n\n    this.consume(TokenType.KW_END_IF, \"Expected 'end if' at the end of if block\")\n\n    return new IfStatement(ifBranch, elseIfs, elseBranch)\n  }\n\n  private singleLineIf(condition: Expression, context: ParsingContext): IfStatement {\n    const singleLineThenContext = context.enterSingleLineThen()\n    const ifStatement = this.nonBlockStatement(singleLineThenContext)\n    const ifBranch = new ConditionedStatements(condition, [ifStatement])\n\n    let elseBranch: Statement[]\n    if (this.tokenMatch(TokenType.KW_ELSE)) {\n      const statement = this.nonBlockStatement(context)\n      elseBranch = [statement]\n    } else {\n      elseBranch = []\n    }\n\n    return new IfStatement(ifBranch, [], elseBranch)\n  }\n\n  private whileStatement(context: ParsingContext): Statement {\n    const whileToken = this.previous()\n\n    const condition = this.expression(context)\n\n    // Should consume newlines or semicolons\n    this.consumeAtLeastOne([TokenType.SEMICOLON, TokenType.NEWLINE], \"Expected semicolon or newline after while-condition\")\n\n    // Consume statements until \"end while\" found - but don't consume it yet\n    const loopContext = context.enterLoop()\n    const whileStatements = this.parseUntil([TokenType.KW_END_WHILE], loopContext)\n\n    // Check for closing \"end while\"\n    this.consume(TokenType.KW_END_WHILE, \"'while' without matching 'end while'\")\n\n    const headerLocation = whileToken.location.upTo(condition.location());\n\n    return new WhileStatement(condition, headerLocation, whileStatements);\n  }\n\n  private forStatement(context: ParsingContext): Statement {\n    const forToken = this.previous();\n\n    const loopVar = this.consume(TokenType.IDENTIFIER_TK, \"Expected identifier as loop variable\") as Identifier\n\n    this.consume(TokenType.KW_IN, \"Expected 'in' after loop-variable in for\")\n\n    const rangeExpression = this.expression(context)\n\n    // Should consume newlines or semicolons\n    this.consumeAtLeastOne([TokenType.SEMICOLON, TokenType.NEWLINE], \"Expected semicolon or newline after for-header\")\n\n    // Consume statements until \"end for\" found - but don't consume it yet\n    const loopContext = context.enterLoop()\n    const forStatements = this.parseUntil([TokenType.KW_END_FOR], loopContext)\n\n    // Check for closing \"end for\"\n    this.consume(TokenType.KW_END_FOR, \"'for' without matching 'end for'\")\n\n    const headerLocation = forToken.location.upTo(rangeExpression.location());\n\n    return new ForStatement(loopVar, rangeExpression, headerLocation, forStatements);\n  }\n\n  private breakStatement(context: ParsingContext): BreakStatement {\n    if (context.insideLoop) {\n      const fullLocation = this.previous().location;\n      return new BreakStatement(fullLocation);\n    } else {\n      throw this.failParsing(\"Keyword 'break' only allowed in for / while loops\")\n    }\n  }\n\n  private continueStatement(context: ParsingContext): ContinueStatement {\n    if (context.insideLoop) {\n      const fullLocation = this.previous().location;\n      return new ContinueStatement(fullLocation);\n    } else {\n      throw this.failParsing(\"Keyword 'continue' only allowed in for / while loops\")\n    }\n  }\n\n  private returnStatement(context: ParsingContext): ReturnStatement {\n    const openingToken = this.previous();\n    let fullLocation: SrcLocation;\n\n    let optReturnValue;\n    if (this.isAtEndOfStatement(context)) {\n      optReturnValue = undefined\n      fullLocation = openingToken.location;\n    } else {\n      optReturnValue = this.functionBodyOrExpr(context) as Expression;\n      fullLocation = openingToken.location.upTo(optReturnValue.location());\n    }      \n    \n    return new ReturnStatement(optReturnValue, fullLocation);\n  }\n\n  private expressionStatement(context: ParsingContext): Statement {\n\n    const statementExprContext = context.enterParsingStatementExpr()\n    const expr = this.expression(statementExprContext)\n\n    // If next token is not SEMICOLON / NEWLINE / EOF then assume it's a statement call\n    if (!this.isAtEndOfStatement(context)) {\n      // Parse comma-separated expressions and build a statement call out of this\n      let args: Expression[] = []\n      do {\n        const argumentExp = this.functionBodyOrExpr(context)\n        args.push(argumentExp)\n      } while(this.tokenMatch(TokenType.COMMA))\n      return new FunctionCallStatement(expr, args)\n    } else {\n      return new ExpressionStatement(expr)\n    }\n  }\n\n  private isAtEndOfStatement(context: ParsingContext): boolean {\n    const nextTokenType = this.peek().tokenType\n    if (context.insideSingleLineThen) {\n      return [TokenType.KW_ELSE, TokenType.SEMICOLON, TokenType.NEWLINE, TokenType.EOF].includes(nextTokenType)\n    } else {\n      return [TokenType.SEMICOLON, TokenType.NEWLINE, TokenType.EOF].includes(nextTokenType)\n    }\n  }\n\n  private assignmentStatement(context: ParsingContext): AssignmentStatement {\n    if(this.check(TokenType.OP_FUNCREF)) {\n      // If there is an '@' sign before the target, skip it.\n      // This allows to write statements like `@target = value`\n      // They behave exactly as `target = value`\n      this.advance()\n    }\n\n    const target: Expression = this.call(context)\n\n    this.consume(TokenType.ASSIGN, \"Expected '=' in assignment\")\n\n    const value = this.functionBodyOrExpr(context)\n\n    if(target instanceof IdentifierExpr || target instanceof DotAccessExpr || target instanceof IndexedAccessExpr) {\n      return new AssignmentStatement(target, value)\n    } else {\n      throw this.failParsing(\"Invalid assignment target\")\n    }\n  }\n\n  private mathAssignmentStatement(tokenType: TokenType, context: ParsingContext): AssignmentStatement {\n\n    const target: Expression = this.call(context)\n\n    const tokenStr = this.mathAssignmentString(tokenType);\n    this.consume(tokenType, `Expected '${tokenStr}' in math-assignment`)\n\n    const value = this.functionBodyOrExpr(context)\n\n    if(target instanceof IdentifierExpr || target instanceof DotAccessExpr || target instanceof IndexedAccessExpr) {\n      return new MathAssignmentStatement(target, tokenType, value)\n    } else {\n      throw this.failParsing(\"Invalid math-assignment target\")\n    }\n  }\n\n  private mathAssignmentString(tokenType: TokenType): string {\n    switch (tokenType) {\n      case TokenType.PLUS_ASSIGN:\n        return \"+=\";\n      case TokenType.MINUS_ASSIGN:\n        return \"+=\";\n      case TokenType.MULT_ASSIGN:\n        return \"+=\";\n      case TokenType.DIV_ASSIGN:\n        return \"+=\";\n      case TokenType.MOD_ASSIGN:\n        return \"+=\";\n      case TokenType.POW_ASSIGN:\n        return \"+=\";\n      default:\n        throw this.failParsing(\"Unexpected math-assignment token type: \" + TokenType[tokenType]);\n      }\n  }\n\n  private expression(context: ParsingContext): Expression {\n    return this.logicOr(context)\n  }\n\n  private logicOr(context: ParsingContext): Expression {\n    let expr = this.logicAnd(context)\n\n    while (this.tokenMatch(TokenType.OP_OR)) {\n      const operator = this.previous()\n      const right = this.logicAnd(context)\n      expr = new LogicExpr(expr, operator, right)\n    }\n\n    return expr\n  }\n\n  private logicAnd(context: ParsingContext): Expression {\n    let expr = this.unaryNot(context)\n\n    while (this.tokenMatch(TokenType.OP_AND)) {\n      const operator = this.previous()\n      const right = this.unaryNot(context)\n      expr = new LogicExpr(expr, operator, right)\n    }\n\n    return expr\n  }\n\n  private unaryNot(context: ParsingContext): Expression {\n    if (this.tokenMatch(TokenType.OP_NOT)) {\n      const operator = this.previous()\n      const right = this.isaComparison(context)\n      return new UnaryExpr(operator, right);\n    } else {\n      return this.isaComparison(context);\n    }\n  }\n\n  private isaComparison(context: ParsingContext): Expression {\n    let expr = this.chainedComparison(context)\n\n    while (this.tokenMatch(TokenType.OP_ISA)) {\n      const operator = this.previous()\n      const right = this.term(context)\n      expr = new BinaryExpr(expr, operator, right)\n    }\n\n    return expr\n  }\n\n  private chainedComparison(context: ParsingContext): Expression {\n    const expr = this.term(context);\n\n    const operands: Expression[] = [expr];\n    const operators: Token[] = [];\n\n    while (this.tokenMatch(TokenType.OP_NOT_EQUALS, TokenType.OP_EQUALS, \n                           TokenType.OP_GREATER, TokenType.OP_GREATER_EQUALS, \n                           TokenType.OP_LESS, TokenType.OP_LESS_EQUALS)) {\n      const operator = this.previous();\n      const right = this.term(context);\n      operators.push(operator);\n      operands.push(right);\n    }\n\n    if (operators.length == 0) {\n      // A single expression was parsed\n      return expr;\n    } else if (operators.length == 1) {\n      // A single comparison was parsed\n      return new BinaryExpr(operands[0], operators[0], operands[1]);\n    } else {\n      // A chained comparison was parsed\n      return new ChainedComparisonExpr(operands, operators);\n    }\n  }\n\n  private term(context: ParsingContext): Expression {\n    let expr = this.factor(context)\n\n    if (!this.isFollowedByUnaryMinus(context)) {\n      while (this.tokenMatch(TokenType.OP_MINUS, TokenType.OP_PLUS)) {\n        const operator = this.previous()\n        const right = this.factor(context)\n        expr = new BinaryExpr(expr, operator, right)\n      }\n    }\n\n    return expr\n  }\n\n  /**\n   * Checks if the expression is followed by an unary-minus\n   *\n   * If at the beginning of statement and expr is a property access or identifier\n   * AND next token is OP_MINUS w/afterSpace AND whatever comes after OP_MINUS is not afterSpace,\n   * then bypass this: don't try to match term\n   */\n  private isFollowedByUnaryMinus(context: ParsingContext): boolean {\n    let followedByMinus = this.peek().tokenType == TokenType.OP_MINUS\n\n    if (context.parsingStatementExpr && followedByMinus) {\n      const hasSpaceBeforeMinus = this.peek().afterSpace\n      const peekOne = this.peekAmount(1)\n      const hasSpaceAfterMinus = peekOne != null && peekOne.afterSpace\n      return hasSpaceBeforeMinus && !hasSpaceAfterMinus\n    } else {\n      return false\n    }\n  }\n\n  private factor(context: ParsingContext): Expression {\n    let expr = this.power(context)\n\n    while (this.tokenMatch(TokenType.OP_DIV, TokenType.OP_MULT, TokenType.OP_MOD)) {\n      const operator = this.previous()\n      const right = this.power(context)\n      expr = new BinaryExpr(expr, operator, right)\n    }\n\n    return expr\n  }\n\n  private power(context: ParsingContext): Expression {\n    let expr = this.unary(context)\n\n    while (this.tokenMatch(TokenType.OP_POW)) {\n      const operator = this.previous()\n      const right = this.unary(context)\n      expr = new BinaryExpr(expr, operator, right)\n    }\n\n    return expr\n  }\n\n  private unary(context: ParsingContext): Expression {\n    if (this.tokenMatch(TokenType.OP_MINUS, TokenType.KW_NEW)) {\n      const operator = this.previous()\n      const right = this.call(context)\n      // Try to convert a negated number to a literal expression\n      if (right instanceof Literal && typeof right.value == \"number\" && operator.tokenType == TokenType.OP_MINUS) {\n        const fullLocation = operator.location.upTo(right.location());\n        return new Literal(-right.value, fullLocation);\n      } else {\n        return new UnaryExpr(operator, right);\n      }\n    } else if (this.tokenMatch(TokenType.OP_FUNCREF)) {\n      return this.functionReference(context)\n    } else {\n      return this.call(context)\n    }\n  }\n\n  private functionReference(context: ParsingContext): Expression {\n    const openingToken = this.previous();\n\n    const refTarget: Expression = this.call(context)\n    if (refTarget instanceof IdentifierExpr \n      || refTarget instanceof DotAccessExpr\n      || refTarget instanceof IndexedAccessExpr) {\n        const fullLocation = openingToken.location.upTo(refTarget.location());\n        return new FunctionRefExpr(refTarget, fullLocation);\n    } else {\n      throw new ParserError(\"Invalid reference target for '@'\", refTarget.location().start)\n    }\n  }\n\n  private call(context: ParsingContext): Expression {\n    let expr = this.primary(context)\n    let continueParsing = true\n\n    while (continueParsing) {\n      // When parsing a statement an opening \"(\" can have different meaning\n      // depending on whether it has a space before it or not. With a space\n      // before it, it should be treated as a grouping-expression. Without \n      // a space it should be treated as a parameter-list.\n      if (context.parsingStatementExpr && this.matchesNonAfterSpaces(TokenType.OPEN_ROUND)) {\n        // Force \"leaving\" the \"statement-parsing\" context, so that subsequent\n        // opening parentheses are treated as in normal expressions.\n        const nonStatementExprContext = context.leaveParsingStatementExpr();\n        expr = this.finishCall(expr, nonStatementExprContext)\n      // When outside of the statement-parsing level (parsing \"pure\" expressions)\n      // we can match opening \"(\" as parameter-lists, regardless of whether they\n      // have a space before them or not.\n      } else if(!context.parsingStatementExpr && this.tokenMatch(TokenType.OPEN_ROUND)){\n        expr = this.finishCall(expr, context)     \n      } else if (this.matchesNonAfterSpaces(TokenType.OPEN_SQUARE)) {\n        expr = this.indexedAccessOrSlicing(expr, context)\n      } else if (this.matchesNonAfterSpaces(TokenType.DOT)) {\n        const propertyName = this.consume(TokenType.IDENTIFIER_TK,\n          \"Expected property name after '.'\") as Identifier\n        expr = new DotAccessExpr(expr, propertyName)\n        // If there is a space after the property name stop parsing\n        // We might be in a statement call\n        if (this.peek().afterSpace) {\n          continueParsing = false\n        }\n      } else {\n        continueParsing = false\n      }\n    }\n\n    return expr\n  }\n\n  private finishCall(callTarget: Expression, context: ParsingContext): Expression {\n    let args: Expression[] = []\n    \n    if (!this.check(TokenType.CLOSE_ROUND)) {\n      do {\n        const argumentExpression = this.functionBodyOrExpr(context)\n        args.push(argumentExpression)\n      } while(this.tokenMatch(TokenType.COMMA))\n    }\n    this.consume(TokenType.CLOSE_ROUND, \"Expected closing ')' after function arguments\")\n    \n    const closingToken = this.previous();\n    const fullLocation = callTarget.location().upTo(closingToken.location);\n\n    return new FunctionCallExpr(callTarget, args, fullLocation);\n  }\n\n  private functionBodyOrExpr(context: ParsingContext): Expression {\n    if (this.tokenMatch(TokenType.KW_FUNCTION)) {\n      return this.functionBody(context)\n    } else {\n      return this.expression(context)\n    }\n  }\n\n  private indexedAccessOrSlicing(targetObj: Expression, context: ParsingContext): Expression {\n    const openingToken = this.previous();\n\n    let slicing = false\n\n    let startExpr: Expression | undefined = undefined\n    let stopExpr: Expression | undefined = undefined\n    let indexExpr: Expression | undefined = undefined\n\n    if(this.tokenMatch(TokenType.COLON)) {\n      // Slicing with no start\n      slicing = true\n      // Check for ']', if not, parse stopExpr\n      if(!this.check(TokenType.CLOSE_SQUARE)) {\n        stopExpr = this.expression(context)\n      }\n    } else {\n      // Parse one expression, and see what happens afterwards\n      const expr = this.expression(context)\n      if(this.tokenMatch(TokenType.COLON)) {\n        // We are slicing and the expression was the start expression\n        slicing = true\n        startExpr = expr\n        // Now we can try to parse the (optional) stop expression\n        if(!this.check(TokenType.CLOSE_SQUARE)) {\n          stopExpr = this.expression(context)\n        }\n      } else {\n        // Not slicing, what we got was THE index expression\n        indexExpr = expr\n      }\n    }\n\n    this.consume(TokenType.CLOSE_SQUARE, \"Expected closing ']' for indexed access. Found: \" + this.peek().tokenType)\n\n    const closingToken = this.previous();\n    const fullRange = SrcLocation.forTokenRange(openingToken, closingToken);\n\n    if (slicing) {\n      return new ListSlicingExpr(targetObj, startExpr, stopExpr, fullRange);\n    } else {\n      return new IndexedAccessExpr(targetObj, indexExpr as Expression, fullRange);\n    }\n  }\n\n  private primary(context: ParsingContext): Expression {\n    if (this.tokenMatch(TokenType.KW_FALSE)) {\n      // Convert \"false\" to literal 0 right away\n      return new Literal(0, this.previous().location);\n      // Convert \"true\" to literal 1 right away\n    } else if (this.tokenMatch(TokenType.KW_TRUE)) {\n      return new Literal(1, this.previous().location);\n    } else if (this.tokenMatch(TokenType.KW_NULL)) {\n      return new Literal(null, this.previous().location);\n    } else if (this.tokenMatch(TokenType.KW_SUPER)) {\n      return this.superExpr(context)\n    } else if (this.tokenMatch(TokenType.INT_LITERAL, TokenType.FLOAT_LITERAL, TokenType.STRING_LITERAL)) {\n      const token = this.previous() as LiteralToken<any>\n      return new Literal(token.value, token.location);\n    } else if (this.check(TokenType.IDENTIFIER_TK)) {\n      return this.identifier();\n    } else if (this.tokenMatch(TokenType.OPEN_ROUND)) {\n      return this.groupingExpr(context);\n    } else if (this.tokenMatch(TokenType.OPEN_SQUARE)) {\n      return this.listLiteral(context)\n    } else if (this.tokenMatch(TokenType.OPEN_CURLY)) {\n      return this.mapLiteral(context)\n    } else {\n      throw this.failForMissingExpression();\n    }\n  }\n\n  private failForMissingExpression(): ParserError {\n    const found = this.peek().tokenType;\n    let msg = \"\";\n    if (found === TokenType.KW_END_IF) {\n      msg = \"'end if' without matching 'if'\";\n    } else if (found === TokenType.KW_END_FOR) {\n      msg = \"'end for' without matching 'for'\";\n    } else if (found === TokenType.KW_END_WHILE) {\n      msg = \"'end while' without matching 'while'\";\n    } else if (found === TokenType.KW_END_FUNCTION) {\n      msg = \"'end function' without matching 'function'\";\n    } else if (found === TokenType.KW_FUNCTION) {\n      msg = \"unexpected keyword 'function' at start of line\";\n    } else {\n      msg = \"Expected expression. Found: \" + TokenType[found];\n    }\n    return this.failParsing(msg);\n  }\n\n  private groupingExpr(context: ParsingContext): GroupingExpr {\n    const openingToken = this.previous();\n    const expr = this.expression(context);\n    this.consume(TokenType.CLOSE_ROUND);\n    const closingToken = this.previous();\n    const fullLocation = SrcLocation.forTokenRange(openingToken, closingToken);\n    return new GroupingExpr(expr, fullLocation);\n  }\n\n  private identifier(): IdentifierExpr {\n    const token = this.consume(TokenType.IDENTIFIER_TK, \"Identifier expected\") as Identifier\n    return new IdentifierExpr(token)\n  }\n\n  private superExpr(context: ParsingContext): SuperExpr {\n    if (context.insideFunction) {\n      const token = this.previous()\n      return new SuperExpr(token.location)\n    } else {\n      throw this.failParsing(\"Keyword 'super' only allowed inside a function\")\n    }\n  }\n\n  private listLiteral(context: ParsingContext): ListExpr {\n    const openingToken = this.previous()\n    let elements: Expression[] = []\n    if (!this.check(TokenType.CLOSE_SQUARE)) {\n      let continueParsing = true\n      do {\n        // Support trailing commas inside list literal\n        if(this.previous().tokenType == TokenType.COMMA && this.check(TokenType.CLOSE_SQUARE)) {\n          // We just parsed a comma, and now comes a closing square - we are done\n          continueParsing = false\n        } else {\n          // Parse an expression inside the list, as usual\n          const argumentExpression = this.expression(context)\n          elements.push(argumentExpression)\n        }\n      } while(this.tokenMatch(TokenType.COMMA) && continueParsing)\n    }\n    this.consume(TokenType.CLOSE_SQUARE, \"Expected closing ']' in list literal\")\n    \n    const closingToken = this.previous()\n    const fullLocation = SrcLocation.forTokenRange(openingToken, closingToken);\n    \n    return new ListExpr(elements, fullLocation);\n  }\n\n  private mapLiteral(context: ParsingContext): MapExpr {\n    const openingToken = this.previous();\n    let elements = new Map<Expression, Expression>()\n    if (!this.check(TokenType.CLOSE_CURLY)) {\n      let continueParsing = true\n      do {\n        // Support trailing commas inside list literal\n        if(this.previous().tokenType == TokenType.COMMA && this.check(TokenType.CLOSE_CURLY)) {\n          // We just parsed a comma, and now comes a closing curly - we are done\n          continueParsing = false\n        } else {\n          // Parse an expression inside the map, as usual\n          const key = this.expression(context)\n          this.consume(TokenType.COLON, \"Expected ':' after key. Found: \" + this.peek().tokenType)\n          const value = this.expression(context)\n          elements.set(key, value)\n        }\n      } while(this.tokenMatch(TokenType.COMMA) && continueParsing)\n    }\n    this.consume(TokenType.CLOSE_CURLY, \"Expected closing '}' in map literal\")\n\n    const closingToken = this.previous()\n    const fullLocation = SrcLocation.forTokenRange(openingToken, closingToken);\n\n    return new MapExpr(elements, fullLocation);\n  }\n\n  private functionBody(context: ParsingContext): FunctionBodyExpr {\n    const openingToken = this.previous();\n    const functionContext = context.enterFunction()\n\n    // Parse arguments\n    let args: Argument[] = []\n    if (this.tokenMatch(TokenType.OPEN_ROUND)) {\n      do {\n        if (this.check(TokenType.IDENTIFIER_TK)) {\n          const identifierExpr = this.identifier()\n          const name = identifierExpr.identifier.value\n          let fullLocation: SrcLocation;\n          let defaultValue: Literal | undefined;\n          if (this.tokenMatch(TokenType.ASSIGN)) {\n            //  Should be literal\n            const defaultValueExpr = this.unary(context) as Expression;\n            defaultValue = this.ensureLiteral(defaultValueExpr);\n            fullLocation = identifierExpr.location().upTo(defaultValue.location());\n          } else {\n            defaultValue = undefined;\n            fullLocation = identifierExpr.location();\n          }\n      \n          const argument = new Argument(name, defaultValue, fullLocation)\n          args.push(argument)\n        }\n      } while (this.tokenMatch(TokenType.COMMA))\n      this.consume(TokenType.CLOSE_ROUND, \"Expected closing ')' after argument list\")\n    }\n\n    // Parse statements\n    const bodyStatements = this.parseUntil([TokenType.KW_END_FUNCTION], functionContext)\n    this.consume(TokenType.KW_END_FUNCTION, \"Expected 'end function' at the end of function-body\")\n\n    const closingToken = this.previous()\n    const fullLocation = SrcLocation.forTokenRange(openingToken, closingToken);\n\n    return new FunctionBodyExpr(args, bodyStatements, fullLocation)\n  }\n\n  private ensureLiteral(expr: Expression): Literal {\n    if (expr instanceof Literal) {\n      return expr as Literal;\n    } else {\n      throw this.failParsing(\"Default value should be literal\");\n    }\n  }\n\n  private consume(tokenType: TokenType, message: string | null = null): Token {\n    if (this.check(tokenType)) {\n      return this.advance()\n    } else if (message != null) {\n      throw this.failParsing(message);\n    } else {\n      const tokenFound = this.peek();\n      const msg = \n        `got ${toOfficialImplTokenName(tokenFound.tokenType)} ` + \n        `where ${toOfficialImplTokenName(tokenType)} is required`;\n      throw this.failParsing(msg);\n    }\n  }\n\n  /**\n   * Tries to consume as many of the token-types as possible, at least one\n   * */\n  private consumeAtLeastOne(tokenTypes: TokenType[], message: string) {\n\n    let shouldConsume = true\n    let tokensConsumed = 0\n\n    while (!this.isAtEnd() && shouldConsume) {\n      let matchFound = false\n      for (let tokenType of tokenTypes) {\n        if (this.check(tokenType)) {\n          matchFound = true\n          tokensConsumed += 1\n          this.advance()\n        }\n      }\n      if (!matchFound) {\n        // Found a token that does not match the expected token-types, stop looping\n        shouldConsume = false\n      }\n    }\n\n    if (tokensConsumed == 0) {\n      const pos = this.peek().location.start;\n      throw new ParserError(message, pos);\n    }\n  }\n\n  private failParsing(message: string): ParserError {\n    let pos = this.peek().location.start;\n    // Pretend that the end of file is at a new line.\n    // The official MiniScript parser apparently operates so.\n    // We need this so that the line-nr matches in the error message.\n    if (this.peek().tokenType === TokenType.EOF && pos.col !== 0) {\n      pos = pos.copy();\n      pos.moveToNewLine();\n    }\n    return new ParserError(message, pos);\n  }\n\n  private tokenMatch(...types: TokenType[]): boolean {\n    for (let tokenType of types) {\n      if (this.check(tokenType)) {\n        this.advance()\n        return true\n      }\n    }\n    return false\n  }\n\n  private matchesNonAfterSpaces(tokenType: TokenType): boolean {\n    const token = this.peek()\n    if (token.tokenType == tokenType && !token.afterSpace) {\n      this.advance()\n      return true\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * Checks tokens until the next newline / semicolon / EOF.\n   * That is: within a statement boundary\n   *\n   * Useful for \"guessing\" statements\n   * */\n  private findTokenWithinStatementBoundary(tokenTypes: TokenType[]): TokenType | null {\n    let idx = this.current\n    while (true) {\n      const token = this.tokens[idx]\n      if ([TokenType.EOF, TokenType.SEMICOLON, TokenType.NEWLINE].includes(token.tokenType)) {\n        // Statement boundary reached\n        return null;\n      } else if (tokenTypes.includes(token.tokenType)) {\n        // Match found\n        return token.tokenType;\n      }\n      idx += 1\n    }\n  }\n\n  private check(tokenType: TokenType): boolean {\n    if (this.current > this.tokens.length) {\n      return false\n    } else {\n      return this.peek().tokenType == tokenType\n    }\n  }\n\n  private advance(): Token {\n    if (!this.isAtEnd()) {\n      this.current += 1\n    }\n    return this.previous()\n  }\n\n  private isAtEnd(): boolean {\n    return this.peek().tokenType == TokenType.EOF\n  }\n\n  private peek(): Token {\n    return this.tokens[this.current]\n  }\n\n  private peekAmount(amount: number): Token | null {\n    const idx = this.current + amount\n    if (idx < this.tokens.length) {\n      return this.tokens[idx]\n    } else {\n      return null\n    }\n  }\n\n  private previous(): Token {\n    return this.tokens[this.current - 1]\n  }\n\n}", "import { Context } from \"../vm/context\";\nimport { MSMap } from \"../vm/msmap\";\nimport { Processor } from \"../vm/processor\";\n\nexport class Runtime {\n\n  constructor(private vm: Processor) {\n  }\n\n  newMap(): MSMap {\n    return new MSMap(this.vm);\n  }\n\n  get globals(): Context {\n    return this.vm.globalContext;\n  }\n\n  addIntrinsic(signature: string, impl: Function) {\n    this.vm.addIntrinsic(signature, impl);\n  }\n\n  addMapIntrinsic(target: MSMap, signature: string, impl: Function) {\n    this.vm.addMapIntrinsic(target, signature, impl);\n  }\n\n}", "import { Code } from \"../../vm/code\";\nimport { Processor } from \"../../vm/processor\";\n\nexport class CooperativeRunner {\n\n  constructor(\n    private vm: Processor,\n    private code: Code) {\n    this.vm.prepareForRunning(code);\n    this.vm.setRunAfterSuspended(false);\n  }\n\n  runSomeCycles() {\n    if (!this.isFinished()) {\n      this.vm.runSomeCycles();\n    }\n  }\n\n  stop() {\n    this.vm.stopRunning();\n  }\n\n  getCurrentSourceLocation(): [string?,  number?] {\n    const fileName = this.vm.getCurrentSrcFileName();\n    const lineNr = this.vm.getCurrentSrcLineNr();\n    return [fileName, lineNr];\n  }\n\n  isFinished(): boolean {\n    const result = this.vm.isFinished();\n    return result; \n  }\n\n  get compiledCode(): Code {\n    return this.code;\n  }\n\n  getLastValue(): any {\n    return this.vm.lastValue;\n  }\n\n}", "import { Code } from \"../../vm/code\";\nimport { Processor } from \"../../vm/processor\";\n\nexport class StdRunner {\n\n  constructor(\n    private vm: Processor,\n    private code: Code) {\n    this.vm.prepareForRunning(code);\n  }\n\n  async runUntilDone() {\n    const vm = this.vm;\n    return new Promise<boolean>((resolve) => {\n      // This will be called when VM is done running.\n      vm.onFinished = () => {\n        resolve(true);\n      };\n      vm.run();\n    });\n  }\n\n  stop() {\n    this.vm.stopRunning();\n  }\n\n  getCurrentSourceLocation(): [string?,  number?] {\n    const fileName = this.vm.getCurrentSrcFileName();\n    const lineNr = this.vm.getCurrentSrcLineNr();\n    return [fileName, lineNr];\n  }\n\n  isFinished(): boolean {\n    const result = this.vm.isFinished();\n    return result; \n  }\n\n  get compiledCode(): Code {\n    return this.code;\n  }\n\n}", "import { Compiler } from \"../compiler/compiler\";\nimport { Debugger } from \"../debugger/debugger\";\nimport { addStandardIntrinsics } from \"../intrinsics/intrinsics\";\nimport { Parser } from \"../parser/parser\";\nimport { Statement } from \"../parser/parserModel\";\nimport { Runtime } from \"../runtime/runtimeApi\";\nimport { Code } from \"../vm/code\";\nimport { Processor, TxtCallback } from \"../vm/processor\";\nimport { CooperativeRunner } from \"./runners/coopRunner\";\nimport { StdRunner } from \"./runners/stdRunner\";\n\nexport type DebuggerCallbacks = {\n  onSrcChange: (d: Debugger) => void, \n  onFinished: (d: Debugger) => void\n}\n\nexport class Interpreter {\n\n  private stderrCallback: TxtCallback;\n\n  private vm: Processor;\n  private _runtime: Runtime;\n\n  constructor(\n    stdoutCallback: TxtCallback | null = null, \n    stderrCallback: TxtCallback | null = null) {\n    if (!stdoutCallback) {\n      stdoutCallback = (line: string) => {\n        console.log(line);\n      }\n    }\n    if (!stderrCallback) {\n      stderrCallback = stdoutCallback;\n    }\n    this.stderrCallback = stderrCallback;\n    this.vm = new Processor(stdoutCallback, stderrCallback);\n    this._runtime = new Runtime(this.vm);\n    addStandardIntrinsics(this.vm);\n  }\n\n  async runSrcCode(srcCode: string, srcName?: string): Promise<boolean> {\n    const code = this.compileSrcCode(srcCode, srcName);\n    if (code) {\n      const runner = new StdRunner(this.vm, code);\n      const result = await runner.runUntilDone();\n      return result;\n    } else {\n      return false;\n    }\n  }\n\n  getStandardRunner(srcCode: string, srcName?: string): StdRunner | null {\n    const code = this.compileSrcCode(srcCode, srcName);\n    if (code) {\n      const runner = new StdRunner(this.vm, code);\n      return runner;\n    } else {\n      return null;\n    }\n  }\n\n  getCooperativeRunner(srcCode: string, srcName?: string): CooperativeRunner | null {\n    const code = this.compileSrcCode(srcCode, srcName);\n    if (code) {\n      const runner = new CooperativeRunner(this.vm, code);\n      return runner;\n    } else {\n      return null;\n    }\n  }\n\n  get runtime(): Runtime {\n    return this._runtime;\n  }\n\n  debugSrcCode(srcCode: string, callbacks: DebuggerCallbacks, srcName?: string): Debugger | null {\n    const code = this.compileSrcCode(srcCode, srcName);\n    if (code) {\n      const d = this.debugCompiledCode(code, callbacks);\n      return d;\n    } else {\n      return null;\n    }\n  }\n\n  // Return a promise that is resolved only when the module code\n  // is done running.\n  runSrcAsModule(moduleName: string, srcCode: string): Promise<void> {\n    const invocationCode = this.compileModuleInvocation(moduleName, srcCode);\n    const vm = this.vm;\n    const promise = vm.runAtCurrentPosition(invocationCode);\n    return promise; \n  }\n\n  stopExecution() {\n    this.vm.stopRunning();\n  }\n\n  private compileSrcCode(srcCode: string, srcName?: string): Code | null {\n    let parsedStatements: Statement[] = [];\n\n    try {\n      const p = new Parser(srcCode);\n      parsedStatements = p.parse();\n    } catch (e: any) {\n      if (e[\"message\"]) {\n        console.error(e);\n        this.stderrCallback(e.message);\n      }\n    }\n\n    if (parsedStatements.length > 0) {\n      const compiler = new Compiler(parsedStatements, srcName);\n      const code = compiler.compile();\n      return code;\n    } else {\n      return null;\n    }\n  }\n\n  private debugCompiledCode(prgCode: Code, callbacks: DebuggerCallbacks): Debugger {\n\n    const vm = this.vm;\n    const dbg = new Debugger(vm);\n\n    dbg.onSrcChange = () => {\n      callbacks.onSrcChange(dbg);\n    };\n    dbg.onFinished = () => {\n      callbacks.onFinished(dbg);\n    }\n    \n    vm.prepareForRunning(prgCode);\n    dbg.start();\n    return dbg;\n  } \n\n  private compileModuleInvocation(moduleName: string, srcCode: string): Code {\n    const p = new Parser(srcCode);\n    const parsedStatements = p.parse();\n    const compiler = new Compiler(parsedStatements, `${moduleName}.ms`);\n    const code = compiler.compileModuleInvocation(moduleName);\n    return code;\n  }\n\n}", "///<reference path='../node_modules/jquery.terminal/js/jquery.terminal.d.ts' />\n\nimport { CooperativeRunner, Interpreter } from \"miniscript-ts\";\n\n\n// Extend official type, which is missing the \"width\" parameter\ntype TOptions = JQueryTerminal.TerminalOptions & {\n  width?: number\n};\n\n\nexport class MSTerminal {\n\n  interp: Interpreter;\n  jqTerm: JQueryTerminal;\n\n  constructor() {\n    const outCallback = (txt: string) => {\n      console.log(txt);\n    }\n    this.jqTerm = undefined as unknown as JQueryTerminal;\n    this.interp = new Interpreter(outCallback, outCallback);\n    this.setupIntrinsics();\n  }\n\n  setup() {\n    const outerThis = this;\n    const options = {\n      onInit: (terminal: JQueryTerminal) => {\n        outerThis.onInit(terminal);\n      },\n      onAfterCommand: (command: string) => {\n        outerThis.onAfterCommand(command);\n      },\n      name: 'ms_terminal',\n      height: 200,\n      width: 450,\n      prompt: '] ',\n      greetings: \"\"\n    } as TOptions;\n\n    const jq = $(\"#term_demo\") as JQuery;\n    const jqTerm = jq.terminal((command: string) => {\n      outerThis.onCommand(command);\n    }, options);\n\n    this.jqTerm = jqTerm;\n    jqTerm.pause();\n  }\n\n  private setupIntrinsics() {\n    const runtime = this.interp.runtime;\n    const outerThis = this;\n\n    runtime.addIntrinsic('print(txt,delim=null)',\n    function(txt: string, delim: string | null) {\n      outerThis.print(txt, delim);\n    });\n\n    runtime.addIntrinsic('input(prompt=null)',\n    function(prompt: string | null): Promise<string> {\n      return outerThis.input(prompt);\n    });\n  }\n\n  private print(txt: string, delim: string | null) {\n    this.jqTerm.echo(txt);\n  }\n\n  private async input(prompt: string | null): Promise<string> {\n    this.jqTerm.resume();\n    if (prompt === null) {\n      prompt = \"\";\n    }\n    return this.jqTerm.read(prompt).then((txt) => {\n      this.jqTerm.pause();\n      return txt;\n    });\n  }\n\n  run(srcCode: string, fileName: string) {\n    const coopRunner = this.interp.getCooperativeRunner(srcCode, fileName);\n    if (coopRunner) {\n      this.runCycles(coopRunner);\n    }\n  }\n\n  private runCycles(coopRunner: CooperativeRunner) {\n    if (!coopRunner.isFinished()) {\n      coopRunner.runSomeCycles();\n      setTimeout(() => {\n        this.runCycles(coopRunner);\n      }, 0);\n    } else {\n      console.log(\"Finished\");\n    }\n  }\n\n  private onInit(term: JQueryTerminal) {\n    //console.log(\"Init\", term);\n  }\n\n  private onCommand(cmd: string) {\n    //console.log(\"Command\", cmd);\n\n  }\n\n  private onAfterCommand(cmd: string) {\n    //console.log(\"After-Command\", cmd);\n  }\n\n}\n", "import { MSTerminal } from \"./msTerminal\";\n\njQuery(($: any, _: any) => {\n  const msTerm = new MSTerminal();\n  msTerm.setup();\n\n  const mainFile = \"demo.ms\";\n\n  fetch(mainFile).then((response) => {\n    return response.text();\n  }).then((srcCode: string) => {\n    msTerm.run(srcCode, mainFile);\n  });\n\n});\n"],
  "mappings": "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",
  "names": ["TokenType", "BC", "ForLoopContext", "_Processor", "fullLocation", "$"]
}
